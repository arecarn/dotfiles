"RYAN CARNEY VIMRC                                                         {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set cpo&vim
set fileformats=unix,dos

let mapleader="\<Space>"

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
"OPERATING SYSTEM VARIABLES                                                {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let s:hasWindows = has("win16") || has("win32") || has("win64")
if s:hasWindows
    let s:vimpath = $HOME."/vimfiles"
    cd $HOME "start in home directory, this is just here for convince
else
    let s:vimpath = $HOME."/.vim"
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
"PLUGINS                                                                   {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"Nebundle{{{2
if has('vim_starting')
    let s:runtimepath = s:vimpath.'/bundle/neobundle.vim/'
    execute 'set runtimepath+='.s:runtimepath
endif

call neobundle#begin(expand(s:vimpath.'/bundle'))
" Let NeoBundle manage NeoBundle
NeoBundleFetch 'Shougo/neobundle.vim'

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}2
"vimproc {{{2
NeoBundle 'Shougo/vimproc.vim', {
            \ 'build' : {
            \     'windows' : 'make -f make_mingw32.mak',
            \     'cygwin' : 'make -f make_cygwin.mak',
            \     'mac' : 'make -f make_mac.mak',
            \     'unix' : 'make -f make_unix.mak',
            \    },
            \ }
"vimproc }}}2

NeoBundle 'Shougo/vimfiler.vim'
NeoBundle 'Shougo/vimshell.vim'

NeoBundle 'pyclewn', {'type' : 'nosync',  'base' : '~/.vim/bundle'}

NeoBundle 'vim-scripts/LanguageTool'
NeoBundle 'scrooloose/syntastic'
NeoBundle 'dbakker/vim-lint'
NeoBundle 'junegunn/vader.vim'

NeoBundle 'AndrewRadev/linediff.vim'
NeoBundle 'arecarn/frisk'
NeoBundle 'henrik/vim-qargs'
NeoBundle 'junegunn/goyo.vim'
NeoBundle 'junegunn/vim-oblique'
NeoBundle 'junegunn/vim-pseudocl' "vim-oblique requirement
" NeoBundle 'haya14busa/incsearch.vim'
NeoBundle 'kana/vim-niceblock'
NeoBundle 't9md/vim-choosewin'
NeoBundle 't9md/vim-quickhl'

NeoBundle 'Lokaltog/vim-easymotion'
" NeoBundle 'rhysd/clever-f.vim'

NeoBundle 'tpope/vim-abolish'
NeoBundle 'tpope/vim-dispatch'
NeoBundle 'tpope/vim-scriptease'
NeoBundle 'tpope/vim-speeddating'
NeoBundle 'vim-scripts/FormatToWidth'
NeoBundle 'vim-scripts/ingo-library' "FormatToWidth requirment

NeoBundle 'tpope/vim-eunuch'
NeoBundle 'tpope/vim-unimpaired'
NeoBundle 'thinca/vim-fontzoom'
NeoBundle 'talek/obvious-resize'

NeoBundle 'TeTrIs.vim'

NeoBundle 'arecarn/Preserve.vim' "TODO Merge into the true one

NeoBundle 'bling/vim-airline'
NeoBundle 'edkolev/tmuxline.vim'

NeoBundle 'chreekat/vim-paren-crosshairs'
NeoBundle 'nathanaelkane/vim-indent-guides'
" NeoBundle 'oblitum/rainbow' "This slows down scrolling a lot

"colorschemes {{{2
NeoBundle 'w0ng/vim-hybrid'
NeoBundle 'junegunn/seoul256.vim'
NeoBundle 'morhetz/gruvbox'
NeoBundle 'altercation/vim-colors-solarized'
"colorschemes }}}2
"syntax {{{2
NeoBundle 'lopter/moin.vim'
NeoBundle 'tpope/vim-markdown'
"syntax }}}2
"git {{{2
NeoBundle 'tpope/vim-fugitive'
NeoBundle 'gregsexton/gitv'
NeoBundle 'int3/vim-extradite'
"git }}}2
"text objects {{{2
NeoBundle 'saihoooooooo/vim-textobj-space'
NeoBundle 'Julian/vim-textobj-variable-segment'
NeoBundle 'coderifous/textobj-word-column.vim'
NeoBundle 'kana/vim-textobj-entire'
NeoBundle 'kana/vim-textobj-indent'
NeoBundle 'kana/vim-textobj-line'
NeoBundle 'kana/vim-textobj-user'
NeoBundle 'mattn/vim-textobj-url'
NeoBundle 'kana/vim-textobj-lastpat'
NeoBundle 'glts/vim-textobj-comment'
NeoBundle 'thinca/vim-textobj-between'
"text objects }}}2
"completion  "{{{2
" NeoBundle 'Shougo/neocomplcache'
NeoBundle 'Shougo/neocomplete'

NeoBundle 'hrsh7th/vim-neco-calc'
NeoBundle 'Shougo/neosnippet.vim'
NeoBundle 'Shougo/neosnippet-snippets'
NeoBundle 'Shougo/echodoc.vim'
"completion  "}}}2
"unite {{{2
NeoBundle 'Shougo/unite.vim'
NeoBundle 'Shougo/unite-ssh'
NeoBundle 'Shougo/unite-outline'
NeoBundle 'Shougo/unite-session'
NeoBundle 'Shougo/neomru.vim'
NeoBundle 'tsukkee/unite-help'
NeoBundle 'ujihisa/unite-colorscheme'
NeoBundle 'kmnk/unite-command'
NeoBundle 'majkinetor/unite-cmdmatch'
NeoBundle 'voi/unite-ctags'
NeoBundle 'thinca/vim-unite-history'
NeoBundle 'kopischke/unite-spell-suggest'
NeoBundle 'kmnk/vim-unite-giti'
"unite }}}2
"operators {{{2
NeoBundle 'tommcdo/vim-exchange'
NeoBundle 'tpope/vim-surround'
NeoBundle 'arecarn/crunch'
NeoBundle 'tpope/vim-commentary'

NeoBundle 'tpope/vim-repeat'
"operators }}}2
"text manipulation {{{2
NeoBundle 'godlygeek/tabular'
NeoBundle 'tommcdo/vim-lion'
NeoBundle 't9md/vim-textmanip'
NeoBundle 'vim-scripts/DrawIt'
"text manipulation }}}2

" NeoBundle 'tmhedberg/matchit'

NeoBundle 'mbbill/undotree'
NeoBundle 'dhruvasagar/vim-table-mode'

NeoBundle 'svermeulen/vim-easyclip'

NeoBundle 'vim-scripts/cmdalias.vim'
NeoBundle 'vim-scripts/UnconditionalPaste'

NeoBundle 'vim-scripts/scons.vim'


" NeoBundle 'inside/vim-search-pulse' "TODO fix this so it works with vim-oblique
" let g:vim_search_pulse_mode = 'pattern'

call neobundle#end()
NeoBundleCheck


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
"PLUGINS CONFIG                                                            {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" neocomplcache {{{2
if neobundle#is_installed('neocomplcache')
    if !isdirectory(s:vimpath.'/utils_local/neocomplcache')
        call mkdir(s:vimpath.'/utils_local/neocomplcache', "p", 0700)
    endif
    let g:neocomplcache_temporary_dir = s:vimpath.'/utils_local/neocomplcache'
    let g:neocomplcache_enable_at_startup = 1
    let g:neocomplcache_enable_smart_case = 1
    let g:neocomplcache_enable_camel_case_completion = 1
    let g:neocomplcache_enable_underbar_completion = 1
    let g:neocomplcache_min_syntax_length = 2
    let g:neocomplcache_lock_buffer_name_pattern = '\*ku\*'
    let g:neocomplcache_enable_auto_delimiter = 1
    let g:neocomplcache_max_list = 100

    let g:neocomplcache_dictionary_filetype_lists = {
                \ 'default' : '',
                \ 'vimshell' : s:vimpath.'/.vimshell_hist',
                \ 'scheme' : s:vimpath.'/.gosh_completions'
                \ }

    " Define keyword, for minor languages
    if !exists('g:neocomplcache_keyword_patterns')
        let g:neocomplcache_keyword_patterns = {}
    endif
    let g:neocomplcache_keyword_patterns['default'] = '\h\w*'

    imap <C-l>  <Plug>(neocomplcache_start_unite_complete)
    imap <C-q>  <Plug>(neocomplcache_start_unite_quick_match)

    " Recommended key-mappings.
    " <CR>: close popup and save indent.
    inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
    function! s:my_cr_function()
        " return neocomplcache#smart_close_popup() . "\<CR>"
        return pumvisible() ? neocomplcache#close_popup() : "\<CR>"
    endfunction
    " <TAB>: completion.
    inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"

    " Enable heavy omni completion.
    if !exists('g:neocomplcache_omni_patterns')
        let g:neocomplcache_omni_patterns = {}
    endif
    let g:neocomplcache_omni_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
    let g:neocomplcache_omni_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
    let g:neocomplcache_omni_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
    let g:neocomplcache_omni_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
    let g:neocomplcache_omni_patterns.ruby = '[^. *\t]\.\h\w*\|\h\w*::'
    nnoremap conc :NeoComplCacheToggle<CR>
endif


"neocomplcache }}}2
" neocomplete {{{2
if neobundle#is_installed('neocomplete')
    " Use neocomplete.
    augroup NEOCOMPLETE
        autocmd!
        " autocmd BufRead * NeoCompleteLock
        autocmd FileType gitcommit let g:neocomplete#enable_auto_close_preview = 0
    augroup END
    nnoremap conc :NeoCompleteToggle<CR>

    let g:neocomplete#enable_at_startup = 1
    let g:neocomplete#disable_auto_complete = 1
    let g:neocomplete#enable_smart_case = 1
    let g:neocomplete#enable_camel_case = 1
    let g:neocomplete#enable_under_bar = 1
    let g:neocomplete#enable_auto_delimiter = 1
    let g:neocomplete#sources#syntax#min_keyword_length = 4
    let g:neocomplete#sources#tags#cache_limit_size = 5000000000000000.0
    let g:neocomplete#max_list = 20

    if !isdirectory(s:vimpath.'/utils_local/neocomplete')
        call mkdir(s:vimpath.'/utils_local/neocomplete', "p", 0700)
    endif
    let g:neocomplete#data_directory = s:vimpath.'/utils_local/neocomplete/'


    " Define dictionary.
    let g:neocomplete#sources#dictionary#dictionaries = {
                \ 'default' : '',
                \ 'vimshell' : $HOME.'/.vimshell_hist',
                \ 'scheme' : $HOME.'/.gosh_completions'
                \ }

    " Define keyword.
    if !exists('g:neocomplete#keyword_patterns')
        let g:neocomplete#keyword_patterns = {}
    endif
    let g:neocomplete#keyword_patterns['default'] = '\h\w*'

    " Plugin key-mappings.
    inoremap <expr><C-g>     neocomplete#undo_completion()
    inoremap <expr><C-l>     neocomplete#complete_common_string()

    " Recommended key-mappings.
    " <CR>: close popup and save indent.
    inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
    function! s:my_cr_function()
        return neocomplete#close_popup() . "\<CR>"
    endfunction

    " inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
    inoremap <expr><CR>  pumvisible() ? "\<Esc>" : "\<CR>"
    inoremap <expr><C-l> neocomplete#complete_common_string()

    " For smart TAB completion.
    inoremap <expr><TAB>  pumvisible() ? "\<C-n>" :
                \ <SID>check_back_space() ? "\<TAB>" :
                \ neocomplete#start_manual_complete()
    function! s:check_back_space() "{{{
        let col = col('.') - 1
        return !col || getline('.')[col - 1]  =~ '\s'
    endfunction"}}}



    inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
    inoremap <expr><C-y>  neocomplete#close_popup()
    inoremap <expr><C-e>  neocomplete#cancel_popup()

    " Enable omni completion.
    autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
    autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
    autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
    autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
    autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

    " Enable heavy omni completion.
    if !exists('g:neocomplete#sources#omni#input_patterns')
        let g:neocomplete#sources#omni#input_patterns = {}
    endif
    let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
    let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
    let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

    " For perlomni.vim setting.
    " https://github.com/c9s/perlomni.vim
    let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
endif
"neocomplete }}}2
"neosnippet {{{2
if neobundle#is_installed('neosnippet-snippets')



    " imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
    "             \ "\<Plug>(neosnippet_expand_or_jump)"
    "             \: pumvisible() ? "\<C-n>" : "\<TAB>"

    " inoremap <expr><TAB>  pumvisible() ? "\<C-n>" :
    "         \ <SID>check_back_space() ? "\<TAB>" :
    "         \ neocomplete#start_manual_complete()
    "   function! s:check_back_space() "{{{
    "     let col = col('.') - 1
    "     return !col || getline('.')[col - 1]  =~ '\s'
    "   endfunction"}}}

    imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
                \ "\<Plug>(neosnippet_expand_or_jump)":
                \  pumvisible() ? "\<C-n>" :
                \ <SID>check_back_space() ? "\<TAB>" :
                \ neocomplete#start_manual_complete()
    function! s:check_back_space() "{{{
        let col = col('.') - 1
        return !col || getline('.')[col - 1]  =~ '\s'
    endfunction

    smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
                \ "\<Plug>(neosnippet_expand_or_jump)"
                \: "\<TAB>"

    if has('conceal')
        set conceallevel=2 concealcursor=i
    endif

    let g:neosnippet#snippets_directory=s:vimpath.'/utils/snippets'
endif
"neosnippet }}}2
"netrw {{{2
"set up line numebring and other good stuff
let g:netrw_bufsettings = 'noma nomod rnu nobl nowrap ro'
"hide .swp .o12 .dbg .lst files in explorer
let g:netrw_list_hide= '.*\.swp$,.*\.o12$,.*\.dbg$,.*\.lst'
"netrw }}}2
" unite.vim {{{2
if neobundle#is_installed('unite.vim')

    let g:unite_data_directory = s:vimpath.'/utils_local/unite/'
    let g:unite_winheight = 10
    let g:unite_source_history_yank_enable = 1
    let g:unite_source_history_yank_limit = 100
    let g:unite_split_rule = 'botright'
    call unite#filters#matcher_default#use(['matcher_fuzzy'])
    call unite#filters#sorter_default#use(['sorter_rank'])
    call unite#custom#source('file_rec,file_rec/async', 'max_candidates', 0)
    call unite#custom#profile('files', 'filters', 'sorter_rank')
    call unite#custom#source('file_rec,file_rec/async,file_mru,file,grep',
                \ 'ignore_pattern', join([
                \ '\.git',  '\.Trash', '\.ini$' ,'\.dbx$', '\.cache$'
                \ ], '\|'))
    " For ack.
    " if executable('ack')
    "     let g:unite_source_grep_command = 'ack'
    "     let g:unite_source_grep_default_opts = '--no-heading --no-color -k -H'
    "     let g:unite_source_grep_recursive_opt = ''
    " endif
    autocmd FileType unite call s:unite_settings()
    function! s:unite_settings()
        imap <Silent><Buffer><Expr> <C-s> unite#do_action('split')
        imap <Silent><Buffer><Expr> <C-v> unite#do_action('vsplit')
        imap <Silent><Buffer><Expr> <C-t> unite#do_action('tabopen')
        imap <Silent><Buffer><Expr> <C-g> unite#do_action('goto')
    endfunction
    let g:unite_source_menu_menus = {}
    let g:unite_source_menu_menus.interpreters = {
                \     'description' : 'Interpreter Menu',
                \ }
    let g:unite_source_menu_menus.interpreters.command_candidates = [
                \   ['VimShell', 'VimShell -split'],
                \   ['bc', 'VimShellInteractive bc'],
                \   ['octave', 'VimShellInteractive octave'],
                \   ['python', 'VimShellInteractive python'],
                \   ['ipython', 'VimShellInteractive ipython --colors=NoColor'],
                \ ]

    nnoremap <TAB><TAB>  :<C-u>Unite -start-insert<CR>
    xnoremap <TAB>g  y:<C-u>Unite -no-empty -no-resize -no-quit grep:.::<C-r>=escape(expand(@@), ' ')<CR>
    nnoremap <TAB>g  :<C-u>Unite -no-empty -no-resize -no-quit grep:.::
    nnoremap <TAB>gw :<C-u>Unite -no-empty -no-resize -no-quit grep:.::<C-r>=expand('<cword>')<CR><CR>
    nnoremap <TAB>f  :<C-u>Unite file file_rec/async -start-insert -input=<CR>
    nnoremap <TAB>fg  :<C-u>Unite file file_rec/git -start-insert -input=<CR>
    nnoremap <TAB>r  :<C-u>Unite file_mru -start-insert<CR>
    nnoremap <TAB>rg :<C-u>Unite register -vertical<CR>
    nnoremap <TAB>b  :<C-u>Unite buffer<CR>
    nnoremap <TAB>o  :<C-u>Unite outline line -vertical<CR>
    nnoremap <TAB>l  :<C-u>Unite line -start-insert<CR>
    nnoremap <TAB>h  :<C-u>Unite help -start-insert<CR>
    nnoremap <TAB>s  :<C-u>Unite session -auto-resize<CR>
    nnoremap <TAB>ss :<C-u>UniteSessionSave<Space>
    nnoremap <TAB>i  :<C-u>Unite menu:interpreters -auto-resize<CR>
    nnoremap <TAB>hc :<C-u>Unite cmdmatch history/command<CR>
    nnoremap <TAB>ms :<C-u>Unite output:message<CR>
    nnoremap <TAB>hs :<C-u>Unite history/search<CR>
    nnoremap <TAB>y  :<C-u>Unite history/yank<CR>
    xnoremap <TAB>y  :<C-u>Unite history/yank<CR>
    nnoremap <TAB>p  :<C-u>Unite process -start-insert<CR>
    nnoremap <TAB>up  :<C-u>Unite neobundle/update<CR>

    " toggle the preview window when I press the "p" key.
    autocmd FileType unite call s:unite_my_settings()
    function! s:unite_my_settings()
        nnoremap <silent><buffer><expr> p
                    \ empty(filter(range(1, winnr('$')),
                    \ 'getwinvar(v:val, "&previewwindow") != 0')) ?
                    \ unite#do_action('preview') : ":\<C-u>pclose!\<CR>"
    endfunction
    let g:neocomplcache_tags_caching_limit_file_size = 5000000000000000.0

endif
" unite }}}2
" vimfiler {{{2
if neobundle#is_installed('vimfiler.vim')
    " Replace netrw commands with vimfiler
    let g:loaded_netrw = 1
    let g:loaded_netrwPlugin = 1
    let g:vimfiler_as_default_explorer = 1

    command! -nargs=* Explore :VimFilerBufferDir <Args>
    command! -nargs=* Sexplore :VimFilerBufferDir -split -horizontal <Args>
    command! -nargs=* Vexplore :VimFilerBufferDir -split  <Args>
    command! -nargs=* Texplore :VimFilerBufferDir -tab <Args>
endif
"vimfiler }}}2
"vimshell {{{2
if neobundle#is_installed('vimshell.vim')
    nnoremap <TAB>sh :VimShell -popup -toggle<CR><ESC>

    let g:vimshell_enable_start_insert = 1
    let g:vimshell_vimshrc_path = s:vimpath.'/utils/vimshell/vimshellrc'

    if !isdirectory(s:vimpath.'/utils_local/vimshell')
        call mkdir(s:vimpath.'/utils_local/vimshell', "p", 0700)
    endif
    let g:vimshell_data_directory = s:vimpath.'/utils_local/vimshell/'
endif
"}}}2

"vimshell }}}2
"echodoc {{{2
if neobundle#is_installed('echodoc.vim')
    let g:echodoc_enable_at_startup=1
    set cmdheight=2
endif

"echodoc }}}2
"oblique {{{2
if neobundle#is_installed('vim-oblique')
    let g:oblique#incsearch_highlight_all = 1
endif
"oblique }}}2
"fugitive {{{2
if neobundle#is_installed('vim-fugitive')
    nnoremap <Leader>gs :Gstatus<CR>
    nnoremap <Leader>gd :Gdiff<CR>
    nnoremap <Leader>gc :Gcommit<CR>
    nmap <Leader>gj <C-W>P<C-N>D
    nmap <Leader>gk <C-W>P<C-P>D
endif
"fugitive }}}2
" frisk {{{2
if neobundle#is_installed('frisk')
    call frisk#AddEngine('yahoo', 'http://search.yahoo.com/search?p=')

    command! Rfrisk call ReloadFrisk()
    "Do the stuff for crunch
    function! ReloadFrisk()
        vs ~/Dropbox/projects/frisk/gc/frisk/plugin/frisk.vim
        wq
        vs ~/Dropbox/projects/frisk/gc/frisk/autoload/frisk/debug.vim
        wq
        vs ~/Dropbox/projects/frisk/gc/frisk/autoload/frisk.vim
        wq
        Runtime ~/Dropbox/projects/frisk/gc/frisk/plugin/*.vim
        Runtime ~/Dropbox/projects/frisk/gc/frisk/autoload/*.vim
        Runtime ~/Dropbox/projects/frisk/gc/frisk/autoload/frisk/*.vim
    endfunction
endif

"frisk }}}2
"tabular {{{2
if neobundle#is_installed('tabular')
    nnoremap <Leader>a :Tabularize/
    xnoremap <Leader>a :Tabularize/
endif
"tabular }}}2
"vim-indent-guides {{{2
if neobundle#is_installed('vim-indent-guides')
    nmap <silent> coig <Plug>IndentGuidesToggle
    let g:indent_guides_enable_on_vim_startup = 0
    let g:indent_guides_guide_size = 1
endif
"vim-indent-guides }}}2
"syntastic {{{2
if neobundle#is_installed('syntastic')
    let g:syntastic_check_on_open = 0
    let g:syntastic_python_checkers = ['python']
    nnoremap cost :SyntasticToggleMode<CR>
endif
"syntastic }}}2
"textmanip {{{2
if neobundle#is_installed('vim-textmanip')
    xmap <C-j> <Plug>(textmanip-move-down)
    xmap <C-k> <Plug>(textmanip-move-up)
    xmap <C-h> <Plug>(textmanip-move-left)
    xmap <C-l> <Plug>(textmanip-move-right)

    " toggle insert/replace with <F10>
    nmap comt <Plug>(textmanip-toggle-mode)
endif
"textmanip }}}2
"vim-quickhl {{{2
if neobundle#is_installed('vim-quickhl')
    nmap m <Plug>(quickhl-manual-this)
    nnoremap gm m
    nnoremap gm m
    xmap m <Plug>(quickhl-manual-this)
    nmap M <Plug>(quickhl-manual-reset)
    xmap M <Plug>(quickhl-manual-reset)
endif
"vim-quickhl }}}2
"vim-easymotion {{{2
if neobundle#is_installed('vim-easymotion')
    map s <Plug>(easymotion-prefix)
    map s/ <Plug>(easymotion-sn)
    map <leader><leader> <Plug>(easymotion-sn)
    map s? <Plug>(easymotion-sn)
    nmap sl <Plug>(easymotion-bd-jk)
endif
"vim-easymotion }}}2
"choosewin {{{2
if neobundle#is_installed('vim-choosewin')
    nmap <C-w><leader> <Plug>(choosewin)
    let g:choosewin_overlay_enable = 1
    let g:choosewin_overlay_clear_multibyte = 1
    let g:choosewin_statusline_replace = 0
endif
"choosewin }}}2
" rainbow{{{2
if neobundle#is_installed('rainbow')
    let g:rainbow_active = 1
endif
" rainbow }}}2
" cmdalias.vim {{{2
if neobundle#is_installed('cmdalias.vim')
    command! Pwf echo expand('%:p')
    augroup VIMRC_aliases
        au!
        au VimEnter * Alias pwf Pwf
        au VimEnter * Alias ex Explore
        au VimEnter * Alias sex Sexplore
        au VimEnter * Alias tex Texplore
        au VimEnter * Alias vex Vexplore
        au VimEnter * Alias vex Vexplore
    augroup END
endif
" cmdalias.vim }}}2
" FormatToWidth {{{2
if neobundle#is_installed('FormatToWidth')
    xmap gQ <Plug>FormatToWidth
endif
" FormatToWidth }}}2
" vim-fontzoom {{{2
if neobundle#is_installed('vim-fontzoom')
    let g:fontzoom_no_default_key_mappings = 1
    nnoremap  ]z <Plug>(fontzoom-larger)
    nnoremap  [z <Plug>(fontzoom-smaller)
endif
" vim-fontzoom }}}2
" linediff{{{2
if neobundle#is_installed('linediff.vim')
    xnoremap <Leader>ld :Linediff<CR>
endif
" linediff.vim }}}2
" languagetool {{{2
"TODO make system independent 18 Mar 2014
let g:languagetool_jar = 'C:/bin/LanguageTool/languagetool-commandline.j'
"}}}2
" vim-easyclip {{{2
if neobundle#is_installed('vim-easyclip')
    let g:EasyClipUseSubstituteDefaults = 1
    let g:EasyClipEnableBlackHoleRedirect = 0
    let g:EasyClipUseCutDefaults = 0
endif
" vim-easyclip }}}2
" vim-textobj-between {{{2
if neobundle#is_installed('vim-textobj-between')
    if neobundle#is_installed('vim-textobj-between')
        let g:textobj_between_no_default_key_mappings = 1
        xmap am <Plug>(textobj-between-a)
        omap am <Plug>(textobj-between-a)
        xmap im <Plug>(textobj-between-i)
        omap im <Plug>(textobj-between-i)
    endif
endif
" vim-textobj-between }}}2
" vim-textobj-comment {{{2
if neobundle#is_installed('vim-textobj-comment')
    let g:textobj_comment_no_default_key_mappings = 1
    xmap a# <Plug>(textobj-comment-a)
    omap a# <Plug>(textobj-comment-a)
    xmap i# <Plug>(textobj-comment-i)
    omap i# <Plug>(textobj-comment-i)
endif
" vim-textobj-comment }}}2
" vim-airline {{{2
if neobundle#is_installed('vim-airline')
    let g:airline#extensions#tabline#enabled = 1
    let g:airline#extensions#tabline#tab_nr_type = 1
    let g:airline#extensions#tabline#buffer_nr_show = 1
    let g:airline_powerline_fonts = 1
    let g:airline_inactive_collapse = 0
    let g:airline_theme='gruvbox'
endif
" vim-airline }}}2
" vim-table-mode {{{2
if neobundle#is_installed('vim-table-mode')
    let g:table_mode_separator = '|'
endif
" vim-table-mode }}}2
" undotree {{{2
if neobundle#is_installed('undotree')
    nnoremap <TAB>ut :UndotreeToggle<CR>:UndotreeFocus<CR>
endif
" undotree }}}2
" goyo {{{2
if neobundle#is_installed('goyo.vim')
    nnoremap cof :<C-U>call SetGoyo(v:count)<CR>
    function! SetGoyo(num)
        if a:num == 0
            Goyo
        else
            execute "Goyo ".string(a:num)
        endif
    endfunction
endif
" goyo.vim }}}2
" scons {{{2
if neobundle#is_installed('scons.vim')
    augroup SCONS
        autocmd!
        autocmd BufNewFile,BufRead SCons*,scons* set filetype=scons
    augroup END
endif
" scons }}}2


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
"FILE TYPE SETTINGS                                                        {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
filetype on
filetype plugin on
filetype indent on
syntax on " allow syntax highlighting
set encoding=utf-8 "make Vim use UTF-8 by default

augroup GIT
    autocmd!
    autocmd FileType gitcommit call CachedPreview(18)
augroup END

function! CachedPreview(max_height)
    if (!&previewwindow) && (expand('%:t') !~# 'index')
        DiffGitCached

        let lines = line('$')

        "close if empty
        if lines == 0
            pclose
            wincmd p
            finish

            " resize to show maximum or less
        elseif line('$') > a:max_height
            let size = a:max_height
        else
            let size = line('$')
        endif
        execute 'resize '.size

        "go to previous window
        wincmd p
    endif
endfunction

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
"UI OPTIONS                                                                {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set colorcolumn=79
set number
set relativenumber
set showcmd
set list
set lazyredraw
set laststatus=2
set listchars=trail:·,tab:»·,extends:→,precedes:←

"Maximize Window on Startup
if has ("gui_running")
    if has("autocmd") && s:hasWindows
        augroup windowsgui:
            autocmd GUIEnter * simalt ~x " maximize in windows
        augroup END
    else
    endif
endif

" Highlight TODO, FIXME, NOTE, etc.
if has("autocmd")
    if v:version > 701
        autocmd Syntax * call matchadd('Todo',  '\W\zs\(TODO\|FIXME\|CHANGED\|XXX\|BUG\|HACK\)')
        autocmd Syntax * call matchadd('Debug', '\W\zs\(NOTE\|INFO\|IDEA\)')
    endif
endif

"gui settings {{{2
if has ("gui_running")
    "Make GVim more like Terminal Vim
    set guioptions-=T "remove toolbar
    set guioptions-=r "remove right-hand scroll bar
    set guioptions-=l "remove right-hand scroll bar
    set guioptions=c "makes dialogs boxes appear like they do in console vim

    "Set Font
    if s:hasWindows
        set guifont=DejaVu_Sans_Mono_For_Powerline:h10:cANSI
        "set guifont=DejaVu_Sans_Mono:h10:cANSI,Lucida_Console:h9:cANSI,Consolas:h9:cANSI
    elseif has('mac')
        set guifont=DejaVu\ Sans\ Mono:h12
        " set guifont=Monaco:h12
    elseif has('unix') && !has('mac') "linux
        set guifont=DejaVu\ Sans\ Mono\ 10
    endif
endif

colorscheme gruvbox
let g:gruvbox_italic=0
set background=dark

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
"CURSOR SETTINGS                                                           {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set scrolloff=6 " Keep 3 lines (top/bottom) for scope
set sidescrolloff=6 " keep 3 lines (side/side) for scope
set sidescroll=1
" In many terminal emulators the mouse works just fine, thus enable it.
if has('mouse')
    set mouse=a
endif

set ttyfast
set ttymouse=xterm2

set cursorline
if has("autocmd")
    augroup CURSOR
        autocmd WinEnter * setlocal cursorline
        autocmd WinLeave * setlocal nocursorline
    augroup END
endif


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
"UNDO & SWAP                                                               {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set undofile
let s:undodir = s:vimpath.'/utils_local/undo//'
execute 'set undodir='.s:undodir
set undolevels=20000
set undoreload=20000


" let s:swap=s:vimpath.'/utils_local/swap//'
set noswapfile
" execute 'set directory='.s:swap
" ^ Here be magic! Quoth the help: (from godlygeek)
" For Unix and Win32, if a directory ends in two path separators "//" or "\\",
" the swap file name will be built from the complete path to the file with all
" path separators substituted to percent '%' signs.  This will ensure file
" name uniqueness in the preserve directory.
set history=10000
set backup
"Make the back up file extension year-month-day_hour ex: file.txt_13-02-24_15
let myvar = strftime("%y-%m-%d_%H")
let myvar = "set backupext=_". myvar
execute myvar
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
"BACKUP                                                                    {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let s:backupdir = s:vimpath.'/utils_local/backup//'
execute 'set backupdir='.s:backupdir

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
"LINE WRAPPING                                                             {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set nowrap
set linebreak
set textwidth=0 "TODO for c make tw=78

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
"SPELLING - THESAURUS                                                      {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set spell
set spelllang=en_us
let &spellfile=s:vimpath.'/utils/spell/spellfile.add'
let &thesaurus=s:vimpath.'/utils/thesaurus/thesaurus.txt'

nnoremap ]gs ]s:sleep 300m<CR>1z=
nnoremap [gs [s:sleep 300m<CR>1z=
nnoremap <C-s> viw<Esc>a<C-X><C-S>
" nnoremap <leader>s viw<Esc>a<C-X><C-S>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
"TABS, INDENTING & FORMAT OPTIONS                                          {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set expandtab
set tabstop=4
set shiftwidth=4
set softtabstop=4
set smarttab

set autoindent
set formatoptions+=n
set formatoptions+=j

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
"FOLDING                                                                   {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"NeatFoldText()"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""{{{2
function! NeatFoldText(foldchar) "TODO handle wide chars with visual col
    let line = ' ' . substitute(getline(v:foldstart), '^\s*"\?\s*\|\s*"\?\s*{{' . '{\d*\s*', '', 'g') . ' '
    let lines_count = v:foldend - v:foldstart + 1
    let lines_count_text = '| ' . printf("%10s", lines_count . ' lines') . ' |'
    " let a:foldchar = matchstr(&fillchars, 'fold:\zs.')
    let foldtextstart = strpart('|' . repeat(a:foldchar, v:foldlevel*2) . line, 0, (winwidth(0)*2)/3)
    let foldtextend = lines_count_text . repeat(a:foldchar, 8)
    let foldtextlength = strlen(substitute(foldtextstart . foldtextend, '.', 'x', 'g')) + &foldcolumn
    return foldtextstart . repeat(a:foldchar, winwidth(0)-foldtextlength) . foldtextend
endfunction
"NeatFoldText()"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}2
set foldtext=NeatFoldText('_')
set foldmethod=indent
set foldcolumn=2
set foldnestmax=1
set foldlevelstart=99

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
"AUTOCMDS                                                                  {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if has("autocmd")
    augroup vimrc
        autocmd!
        autocmd BufWritePost .vimrc,_vimrc,vimrc,.gvimrc,_gvimrc,gvimrc so $MYVIMRC
    augroup END

    augroup AllFiles
        autocmd!
        autocmd FocusLost * silent! wall
    augroup END

    augroup QuickFix
        autocmd!
        "opens quick fix window on the bottom of all screens
        autocmd FileType qf wincmd J
    augroup END

    if s:hasWindows
        augroup TEX
            autocmd!
            autocmd BufEnter *.tex setf tex
            "autocmd BufWritePost *.tex cd %:p:h | !start /min pdflatex %:t
            autocmd BufWritePost *.tex cd %:p:h | !start pdflatex %:t
            autocmd BufEnter *.tex setlocal concealcursor=
        augroup END
    else
        augroup TEX
            autocmd!
            autocmd BufWritePost *.tex cd %:p:h | !pdflatex %:t
            autocmd BufEnter *.tex setlocal concealcursor=
        augroup END
    endif
endif

function! PrintCscopeOptions()
    echo "g: Definition"
    echo "c: Functions calling this function"
    echo "d: Functions called by this function"
    echo "f: This file"
    echo "i: Files #including this file"
    echo "s: This C symbol"
    echo "t: This text string"
    echo "e: This egrep pattern"
endfunction
execute "nnoremap <Leader>csf :call PrintCscopeOptions()<CR>:cs find "
execute "nnoremap <Leader>cs :call PrintCscopeOptions()<CR>:cs find   <C-r><C-w><HOME>".repeat('<Right>',8)

set cscoperelative
set cscopetag

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
"SEARCHING                                                                 {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set wrapscan
set incsearch
set ignorecase
set smartcase

set path=**,.,./**

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
"GENERAL BEHAVIOR                                                          {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set clipboard=unnamedplus,unnamed
set splitright

"disable dang error{visual}bells for good
if has("autocmd")
    augroup noBells
        autocmd!
        autocmd GUIEnter * set vb t_vb=
        autocmd VimEnter * set vb t_vb=
    augroup END
endif

set switchbuf=usetab
set shortmess+=a
set autowriteall

"automatically read file when it's changed outside of Vim
set autoread
if has("autocmd")
    augroup autoread
        autocmd CursorHold * call Timer()
    augroup END
endif
function! Timer()
    if expand("%") == "[Command Line]"
    else
        call feedkeys("f\e")
        checktime
    endif
endfunction

set updatetime=5000  "milliseconds
set confirm
set backspace=indent,eol,start
set tags=tags;/ "the ";/" allows you to look back wards
set exrc
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
"COMPLETION                                                                {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set wildmode=longest,full
set wildmenu
set completeopt=menuone,menu,preview
set wildcharm=<TAB>
set wildignore=*.o,*.obj,*.pyc,*~,*.git,*.hg*,*.svn,*.DS_Store

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
"MAPPINGS & COMMANDS                                                       {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set timeout
set timeoutlen=500
set updatetime=1000

set grepprg=ack\ -H\ --nocolor\ --nogroup

"Navigation
nnoremap <expr> k (v:count == 0 ? 'gk' : 'k')
nnoremap <expr> j (v:count == 0 ? 'gj' : 'j')
nnoremap gk k
nnoremap gj j

xnoremap gr r<space>gvo<esc>R

nnoremap <leader>u :call Underline()<CR>

function! Underline()
    let char = nr2char(getchar())
    execute "normal! yypVr".char
endfunction

inoremap <C-F> <ESC>gwapa

"TODO Is the word under the cursor a number?
function! DoNum(operator)
    let line = getline('.')
    let cIndex = getpos('.')[2] -1 "TODO handle virtual edit
    echom cIndex
    execute "let rLine = line[".cIndex.":]"
    echom "relavant line =".rLine
    " let rLine = substitute(rLine, '\(\d\+\|0x\x\+\)', '\=submatch(0)*10','')
    execute "let rLine = substitute(rLine, \"\(\d\+\|0x\x\+\)\", \"\=submatch(0)*10\",\"\")"
    echom rLine
    let cIndex -= 1
    execute "let line = line[:".cIndex."].rLine"
    echom line
    call setline('.', line)
endfunction

function! CalculateCursor(x, operator)
    let p = @/
    try
        silent exe "s%-\\?\d*\\%#\\d\\+%\\=submatch(0) " . a:operator . " a:x%"
        exe "normal \<C-O>"
    catch /^Vim\%((\a\+)\)\=:E486/
        try
            silent exe "normal /\\%#.\\{-}\\zs\\d\\+/b\<CR>"
            exe "s%-\\?\d*\\%#\\d\\+%\\=submatch(0) " . a:operator . " a:x%"
            exe "normal \<C-O>"
        catch /^Vim\%((\a\+)\)\=:E486/
        endtry
    finally
        let @/ = p
    endtry
endfunction

vnoremap <silent><c-x> :<C-U>'<,'>call CalculateCursor(v:count1, "-")<CR>:noh<CR>gv
vnoremap <silent><c-a> :<C-U>'<,'>call CalculateCursor(v:count1, "+")<CR>:noh<CR>gv

noremap <silent>g<c-x> :<C-U>call CalculateCursor(v:count1, "*")<CR>:noh<CR>
vnoremap <silent>g<c-x> :<C-U>'<,'>call CalculateCursor(v:count1, "*")<CR>:noh<CR>gv

noremap <silent>g<c-a> :<C-U>call CalculateCursor(v:count1, "/")<CR>:noh<CR>
vnoremap <silent>g<c-a> :<C-U>'<,'>call CalculateCursor(v:count1, "/")<CR>:noh<CR>gv


nnoremap cotw :<C-U>setlocal textwidth=
nnoremap cocl :<C-U>setlocal conceallevel=

"update diff with a key mapping
nnoremap du :diffupdate<CR>
nnoremap <silent><leader>dt :PreserveSave<CR>:%s,\s\+$,,ge<CR>:PreserveRestore<CR>
nnoremap <silent><C-l> :redraw!<CR><C-l>

nnoremap <TAB>rc :e $MYVIMRC<CR>


"map F9 - F12 (like hjkl) to resize windows
nnoremap  <silent><F9>  :ObviousResizeLeft<CR>
nnoremap  <silent><F10> :ObviousResizeDown<CR>
nnoremap  <silent><F11> :ObviousResizeUp<CR>
nnoremap  <silent><F12> :ObviousResizeRight<CR>

nnoremap <C-W>d :bd<CR>

" make more undoes possible after leaving insert mode
inoremap <C-u> <C-g>u<C-u>
inoremap <C-w> <C-g>u<C-w>
inoremap <BS> <C-g>u<BS>
inoremap <Del> <C-g>u<Del>
inoremap <END> <C-g>u<END>

noremap Y y$

nnoremap =ae :call Preserve("normal! gg=G")<CR>
nnoremap =ie :call Preserve("normal! gg=G")<CR>
nnoremap yae :call Preserve("normal! ggyG")<CR>
nnoremap yie :call Preserve("normal! ggyG")<CR>

nnoremap <Leader>gcd :cd! %:h<Cr>:pwd<Cr>
nnoremap <Leader>cd :lcd! %:h<Cr>:pwd<Cr>
nnoremap <leader>e :e **/*
nnoremap <leader>f :find<SPACE>*
nnoremap <leader>qa :qa!<Cr>
nnoremap <leader>q :q!<Cr>

nnoremap <Leader>yf :let @f=expand('%:p')<CR>:echo @f.' ---> yanked into register f'<CR>
nnoremap <Leader>yd :let @f=expand('%:h')<CR>:echo @f.' ---> yanked into register f'<CR>

"disable Ex mode key and map it to something awesome
nnoremap Q @q
"replay macro for each line of a visual selection
xnoremap Q :normal! @q<CR>
"repeat last command for each line of a visual selection
xnoremap . :normal! .<CR>
nnoremap <C-q> .n

"navigation in command line
cnoremap <C-p> <UP>
cnoremap <C-n> <DOWN>
cnoremap <C-h> <LEFT>
cnoremap <C-l> <RIGHT>
cnoremap <C-a> <HOME>
cnoremap <C-e> <END>

"current file and directory abbreviations
cabbrev %o <C-r>=expand('%:p:r:.')<CR>
cabbrev %f <C-r>=expand('%:p:.')<CR>
cabbrev %d <C-r>=expand('%:h:.')<CR>/
nnoremap <leader>eo :e <C-r>=expand('%:p:r:.')<CR>
nnoremap <leader>ef :e <C-r>=expand('%:p:.')<CR>
nnoremap <leader>ed :e <C-r>=expand('%:h:.')<CR>/

command! Psnr call feedkeys(":grep! \<C-R>\<C-W> | Qdo %s/\<C-R>\<C-W>//gc\<LEFT>\<LEFT>\<LEFT>")

"accept completion (requires "set wildcharm = <TAB>)
cnoremap <C-y> <SPACE><BS><TAB>

nnoremap S i<cr><esc>k$

nnoremap gJ ddpkJ

nnoremap <silent> <leader>S :execute ':s#\V'.escape(nr2char(getchar()), '\').'#\r#g'<CR>
nnoremap <silent> <leader>gS :execute ':s#\s*\V'.escape(nr2char(getchar()), '\').'\v\s*#\r#g'<CR>
xnoremap <silent> <leader>J :<C-U>execute '''<,''>:s#\n#\V'.escape(nr2char(getchar()), '\').'#g'<CR>
xnoremap <silent> <leader>gJ :<C-U>execute '''<,''>:s#\n#\V'.escape(nr2char(getchar()), '\').' #g'<CR>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
"SCRIPTS                                                                   {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
nnoremap <leader>m  :call SearchPosition()<CR>
nnoremap <leader>M  :let @/ = ""<CR>
function! SearchPosition()
    if @/ !~ '\v(\\\%\d+[lc](\\\|)?)+'
        let @/ = ''
        " echo "pattern didn't match = ".@/
    else
        let @/ .= '\|'
        " echo "added bar = ".@/
    endif

    let line = getpos('.')[1]
    let col = getpos('.')[2]
    execute "let @/ .= '\\%".line."l'"
    execute "let @/ .= '\\%".col."c'"
endfunction

xnoremap g* :<C-U>call AddToSearch()<CR>
function! AddToSearch()
    let save_reg = @@
    if @/ != ''
        let @/ .= '\|'
    endif
    normal! gvy
    let @/ .= @@
    let @@ = save_reg
endfunction

nnoremap gb :<C-U>exec "call Go2Buff('forward',".v:count.")"<CR>
nnoremap gB :<C-U>exec "call Go2Buff('backward',".v:count.")"<CR>
function! Go2Buff(forwardOrBackward, count)
    if a:count == 0
        echom a:count. " using bn"
        if a:forwardOrBackward == "forward"
            execute "normal! :bn\<CR>"
        elseif a:forwardOrBackward == "backward"
            execute "normal! :bp\<CR>"
        endif
    else
        execute "normal! :".a:count."b\<CR>"
    endif
endfunction

command!  PreviewTagToggle call PreviewWordToggle()
nnoremap <Leader>tp :ptjump <C-r><C-w><CR>

"Compile {{{2
"save everything and then gcc the current file then run the file returned by
"gcc
command! Gcc call Compile('gcc\ %\ -o\ %:t:r', 'gcc', 'exe')
command! Gpp call Make()
command! Csc call Compile('csc\ %', 'cs', 'exe')

command! Py cd %:p:h|compiler python|make|cwindow

function! Compile(MakeProgram, Compiler, excutable)
    let s:oldmakeprg = &makeprg
    execute "set makeprg=" . a:MakeProgram
    execute "compiler " . a:Compiler
    let s:filename = expand("%:t:r")
    echo s:filename
    wa
    lcd %:p:h
    make!
    cclose
    cwindow
    if &buftype != "quickfix"
        if exists(':VimShellSendString')
            wincmd p
            VimShellBufferDir -popup
            resize 10
            wincmd p
            if s:hasWindows
                execute "VimShellSendString exe " . s:filename . ".exe"
            else
                execute "VimShellSendString exe ./" . s:filename
            endif
        elseif s:hasWindows
            execute "!" . s:filename . ".exe"
        else "linux
            echom "help fix me!!!!!!!!!!!!!!!!!!!"
            execute "!./" . s:filename
        endif
    else
    endif

    let &makeprg= s:oldmakeprg
endfunction "}}}2


function! Make()
    let s:oldmakeprg = &makeprg
    let &makeprg='[[ -f Makefile ]] && make || make -C'
    lcd %:p:h
    wa
    execute make!
    cclose
    cwindow
    if &buftype != "quickfix"
        if exists(':VimShellSendString')
            wincmd p
            VimShellBufferDir -popup
            resize 10
            wincmd p
            if s:hasWindows
                execute "VimShellSendString exe mycpp.exe"
            else
                execute "VimShellSendString exe ./mycpp"
            endif
        elseif s:hasWindows
            execute "!mycpp.exe"
        else "linux
            echo not working
            execute "!mycpp"
        endif
    else
    endif

    let &makeprg= s:oldmakeprg
endfunction!


function! SetMkfile()
    let filemk = "Makefile"
    let pathmk = "./"
    let depth = 1
    while depth < 4
        if filereadable(pathmk . filemk)
            return pathmk
        endif
        let depth += 1
        let pathmk = "../" . pathmk
    endwhile
    return "."
endfunction

" command! -nargs=* Make tabnew | let mkpath = SetMkfile() | make <Args> -C $mkpath | cwindow 10

function! Maker(args)
    wall
    wall
    cd %:p:h
    let mkpath = SetMkfile()
    execute 'make!'.a:args.' -C '.mkpath
    cclose
    cwindow
    if &buftype != "quickfix"
        if exists(':VimShellSendString') && s:hasWindows
            wincmd p
            VimShellBufferDir -popup
            wincmd K
            resize 10
            wincmd p
            if s:hasWindows
                execute "VimShellSendString exe mycpp.exe"
            else
                execute "VimShellSendString exe ./mycpp"
            endif
        elseif s:hasWindows
            execute "!mycpp.exe"
        else "linux
            execute '!./mycpp'
        endif
    endif
endfunction

command! -nargs=* Maker call Maker('<Args>')

command! -nargs=* MyMake make! <Args> | cwindow

"Crunch Dev Scripts"""""""""""""""""""""""""""""""""""""""""""""""""""""""{{{2
command! Rcrunch call ReloadCrunch()
"Do the stuff for crunch
function! ReloadCrunch()
    vs ~/Dropbox/projects/crunch/crunch/autoload/crunch/debug.vim
    wq
    vs ~/Dropbox/projects/crunch/crunch/autoload/crunch.vim
    wq
    vs ~/Dropbox/projects/crunch/crunch/plugin/crunch.vim
    wq
    Runtime ~/Dropbox/projects/crunch/crunch/plugin/*.vim
    Runtime ~/Dropbox/projects/crunch/crunch/autoload/*.vim
    Runtime ~/Dropbox/projects/crunch/crunch/autoload/crunch/*.vim
endfunction

command! TcrunchS call TestCrunchShell()
function! TestCrunchShell()
    if s:hasWindows
        !runVimTests \Users\arecarn\Dropbox\projects\crunch\crunch\tests
    else
        !runVimTests.sh  ~/Dropbox/projects/crunch/crunch/tests
    endif
endfunction

command! TcrunchVs call TestCrunchVShell()
function! TestCrunchVShell()
    call ReloadCrunch()
    RunVS runVimTests C:/Users/arecarn/Dropbox/projects/crunch/crunch/tests
    if s:hasWindows
        RunVSrunVimTests C:\Users\arecarn\Dropbox\data\code\VimScript\myplugins\crunch\tests
    else
        RunVS runVimTests.sh  ~/Dropbox/projects/crunch/crunch/tests
    endif
endfunction

"do crunch tests
if s:hasWindows
    nnoremap <Leader>ct :!cd \Users\arecarn\Dropbox\repos\crunch\crunch\ && gvim -u .vimrc_minimal +Vader*<CR>
    nnoremap <Leader>tc :!cd \Users\arecarn\Dropbox\repos\crunch\crunch\ && gvim -u .vimrc_minimal<CR>
else
    nnoremap <Leader>ct :!cd ~/Dropbox/repos/crunch/crunch && /usr/local/bin/vim -u .vimrc_minimal +Vader\*<CR>
    nnoremap <Leader>tc :!cd ~/Dropbox/repos/crunch/crunch && /usr/local/bin/vim -u .vimrc_minimal<CR>
endif

"Crunch Dev Scripts"""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}2

"Run in VimShell""""""""""""""""""""""""""""""""""""""""""""""""""""""""""{{{2
command! -nargs=* VshSend call RunInVimShell('<Args>')
function! RunInVimShell(cmd)
    VimShellBufferDir -popup
    execute "VimShellSendString " . a:cmd
endfunction
"Run in VimShell""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}2

"add numbers to the front or end of a line
cabbrev numend s/$/\=1-line("'<")+line(".")/c
cabbrev numfront s/^/\=1-line("'<")+line(".")/c

"Details:
"s/\d\+/ : Match one or more digits (\d\+) on any line (:%) and substitute (s).
"            \= : for each match, replace with the result of the following expression:
"printf("0x%04x", : produce a string using the format "0x%04x", which corresponds to a literal 0x followed by a four digit (or more) hex number, padded with zeros.
"submatch(0) : The result of the complete match (i.e. the number).
cabbrev tohex s/\d\+/\=printf("0x%x", submatch(0))
"find the first occurrence of a hex digit and changes it to decimal
cabbrev todec s/0x\x\+/\=printf("%d", submatch(0))
cabbrev toasc s/0x\x\+/\=printf("%c", submatch(0))
"delete the current character and replace it with it's ASCII Decimal value
nnoremap <Leader>tad xi<C-r>=printf("%d",char2nr("<C-r>""))<CR><ESC>
"delete the current character and replace it with it's ASCII Hex value
nnoremap <Leader>tah xi<C-r>=printf("0x%x",char2nr("<C-r>""))<CR><ESC>
"noremap <Leader>cs  :s/./\=printf("Ox%x + ",char2nr("submatch(0)"))/gc<CR>


"reverse selection kind of works
vnoremap <silent> <leader>is :<c-u>let old_reg_a=@a<cr>
            \:let old_reg=@"<cr>
            \gv"ay
            \:let @a=substitute(@a, '.\(.*\)\@=',
            \ '\=@a[strlen(submatch(1))]', 'g')<CR>
            \gvc<C-R>a<Esc>
            \:let @a=old_reg_a<CR>
            \:let @"=old_reg<CR>

if has('vim_starting')
    nnoremap <unique> <script> <plug>MixedCaseOperator <SID>MixedCaseOperator
    nnoremap <SID>MixedCaseOperator :<C-U>set opfunc=MixedCase<CR>g@
    if !hasmapto('<Plug>MixedCaseOperator')
        nmap <unique> gM <Plug>MixedCaseOperator
    endif

    nnoremap <unique> <script> <plug>MixedCaseOperatorLine <SID>MixedCaseOperatorLine
    nnoremap <SID>MixedCaseOperatorLine :<C-U>set opfunc=MixedCase<bar>exe 'norm! 'v:count1.'g@_'<CR>
    if !hasmapto('<plug>MixedCaseOperatorLine')
        nmap <unique> gMM <plug>MixedCaseOperatorLine
    endif

    xnoremap <unique> <script> <plug>VisualMixedCaseOperator  <SID>VisualMixedCaseOperator
    xnoremap <SID>VisualMixedCaseOperator :<C-U>call MixedCase(visualmode())<CR>
    if !hasmapto('<Plug>VisualMixedCaseOperator')
        xmap <unique> gM <Plug>VisualMixedCaseOperator
    endif
endif


function! MixedCase(type)
    "Backup Settings That We Will Change
    let sel_save = &selection
    let cb_save = &clipboard
    "make selection and clipboard work the way we need
    set selection=inclusive clipboard-=unnamed clipboard-=unnamedplus
    "Backup The Unnamed Register, Which We Will Be Yanking Into    "Backup The Unnamed Register, Which We Will Be Yanking Into
    let reg_save = @@

    if a:type =~ '^.$'
        "if type is 'v', 'V', or '<C-V>' (i.e. 0x16) then reselect the visual region
        silent exe "normal! `<" . a:type . "`>y"
        let type=a:type
    elseif a:type == 'block'
        silent exe "normal! `[\<C-V>`]y"
        let type=''
    elseif a:type == 'line'
        "line-based text motion
        silent exe "normal! `[V`]y"
        let type='V'
    else
        silent exe "normal! `[v`]y"
        let type='v'
    endif
    let regtype = type

    let repl = substitute(@@, '\w\+', '\u\L&', 'g')
    "don't capitalize the  t in can't or the re in your're
    let repl = substitute(repl, '\w\+', '\u&', 'g')

    call setreg('@', repl, regtype)

    normal! gvp
    set nohlsearch

    "Restore Saved Settings And Register Value
    let @@ = reg_save
    let &selection = sel_save
    let &clipboard = cb_save
endfunction

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
"FIN                                                                       {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
try
    source ~/.vimrc_local
    source ./.vimrc_local
catch
endtry

"Refreshing airline
"TODO see why this has to be last
if !has('vim_starting') && g:loaded_airline
    AirlineRefresh
    normal! gtgT
endif "}}}2


set  modeline
" vim: textwidth=78
" vim: foldmethod=marker
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}

" -                                                                        {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set cpo&vim
set fileformats=unix,dos
set encoding=utf-8 "make Vim use UTF-8 by default

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" OPERATING SYSTEM VARIABLES                                               {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let s:has_windows = has("win16") || has("win32") || has("win64")
if s:has_windows
    let s:vim_path = $HOME."/vimfiles"
    cd $HOME "start in home directory, this is just here for convince
else
    let s:vim_path = $HOME."/.vim"
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" COMMAND LINE                                                             {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set wildmode=full
set wildmenu
set wildcharm=<TAB>

" File Searching
" ignored files
set wildignore=*.o,*.obj,*.pyc,*.DS_Store,*.out,HEAD,*.lst,*.i,*.map,tags*,cscope.out
" lower priority files suffixes
set suffixes=.bak,~,.o,.info,.swp,.obj,.git,.hg,.svn

set path=
set path+=.  " To search relative to the directory of the current file
set path+=,, " To search in the current directory
set path+=** "relative to the current directory search recursively

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" CURSOR SETTINGS                                                          {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set scrolloff=6 " Keep lines (top/bottom) for scope
set sidescrolloff=6 " keep lines (side/side) for scope
set sidescroll=3
" In many terminal emulators the mouse works just fine, thus enable it.
if has('mouse')
    set mouse=a
endif

set ttyfast
set ttymouse=xterm2

" set cursorline
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" UNDO & SWAP                                                              {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set undofile
let s:undodir = s:vim_path.'/utils_local/undo//'
execute 'set undodir='.s:undodir
set undolevels=20000
set undoreload=20000


" let s:swap=s:vim_path.'/utils_local/swap//'
set noswapfile
" execute 'set directory='.s:swap
" ^ Here be magic! Quoth the help: (from godlygeek)
" For Unix and Win32, if a directory ends in two path separators "//" or "\\",
" the swap file name will be built from the complete path to the file with all
" path separators substituted to percent '%' signs.  This will ensure file
" name uniqueness in the preserve directory.
set history=10000
set backup
" Make the back up file extension year-month-day_hour ex: file.txt_13-02-24_15
let backupext = "_" . strftime("%y-%m-%d_%H")
execute "set backupext=" . backupext
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" BACKUP                                                                   {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let s:backupdir = s:vim_path.'/utils_local/backup//'
execute 'set backupdir='.s:backupdir

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" LINE WRAPPING                                                            {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set nowrap
set linebreak
set textwidth=0 "TODO for c make tw=78
if v:version >= 704 && has("patch338")
    set breakindent
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" SPELLING - THESAURUS                                                     {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set spell
set spelllang=en_us
let &spellfile=s:vim_path.'/utils/spell/spellfile.add'
let &thesaurus=s:vim_path.'/utils/thesaurus/thesaurus.txt'

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" TABS, INDENTING & FORMAT OPTIONS                                         {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set expandtab
set tabstop=4
set shiftwidth=4
set softtabstop=4
set smarttab

set autoindent
"these are buffer local let make them everywhere
set formatoptions+=n "recognize lists
set formatlistpat+=\\\|^\\s*[-*]\\s* "recognize lists with * or -

set formatoptions+=j "remove comments leader when joining

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" FOLDING                                                                  {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set foldcolumn=2
set foldnestmax=3
set foldlevelstart=99

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" AUTOCMDS                                                                 {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if has("autocmd")
    augroup vimrc
        autocmd!
        autocmd BufWritePost *vimrc* source %
    augroup END


    augroup AllFiles
        autocmd!
        autocmd FocusLost * silent! wall
    augroup END

    augroup QuickFix
        autocmd!
        "opens quick fix window on the bottom of all screens
        autocmd FileType qf wincmd J

        " Automatically open, but do not go to (if there are errors) the
        " quickfix / location list window, or close it when is has become
        " empty.
        "
        " Note: Must allow nesting of autocmds to enable any customizations for
        " quickfix buffers.
        "
        " Note: Normally, :cwindow jumps to the quickfix window if the command
        " opens it (but not if it's already open). However, as part of the
        " autocmd, this doesn't seem to happen.
        autocmd QuickFixCmdPost [^l]* nested cwindow
        autocmd QuickFixCmdPost    l* nested lwindow
        autocmd FileType qf call s:quick_fix_list_settings()
    augroup END

    function! s:quick_fix_list_settings() abort
        nnoremap <buffer> q  <C-W>q
        nnoremap <buffer> t  <C-W><CR><C-W>TgT<C-W>j
        nnoremap <buffer> T  <C-W><CR><C-W>T
        nnoremap <buffer> o  <CR><C-W>p
        nnoremap <buffer> S  <C-W><CR><C-W>K
        nnoremap <buffer> s  <C-W><CR><C-W>K<C-W>b
        nnoremap <buffer> v  <C-W><CR><C-W>H<C-W>b<C-W>J<C-W>t
        nnoremap <buffer> gv <C-W><CR><C-W>H<C-W>b<C-W>J
    endfunction

    if s:has_windows
        augroup TEX
            autocmd!
            autocmd BufEnter *.tex setf tex
            "autocmd BufWritePost *.tex cd %:p:h | !start /min pdflatex %:t
            autocmd BufWritePost *.tex cd %:p:h | !start pdflatex %:t
            autocmd BufEnter *.tex setlocal concealcursor=
        augroup END
    else
        augroup TEX
            autocmd!
            autocmd BufWritePost *.tex cd %:p:h | !pdflatex %:t
            autocmd BufEnter *.tex setlocal concealcursor=
        augroup END
    endif
endif

"for the case that a commit starts with 'vim:' (a valid start to a modeline)
"this will be interpreted as
augroup git
    autocmd!
    autocmd FileType gitrebase setlocal nomodeline
augroup END

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" SEARCHING                                                                {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set wrapscan
set incsearch
set ignorecase
set smartcase

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" TAGS                                                                     {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set tags=tags;/ "search backwards for the tags
set cscoperelative
set cscopequickfix=s-,c-,d-,i-,t-,e-

function! PrintCscopeOptions()
    echo "g: Definition"
    echo "c: Functions calling this function"
    echo "d: Functions called by this function"
    echo "f: This file"
    echo "i: Files #including this file"
    echo "s: This C symbol"
    echo "t: This text string"
    echo "e: This egrep pattern"
endfunction
execute "nnoremap <Leader>csf :call PrintCscopeOptions()<CR>:cs find "
execute "nnoremap <Leader>cs :call PrintCscopeOptions()<CR>:cs find   <C-r><C-w><HOME>".repeat('<Right>',8)
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" GENERAL BEHAVIOR                                                         {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
syntax on " allow syntax highlighting
set clipboard=unnamedplus,unnamed
set splitright

" disable dang error{visual}bells for good
if has("autocmd")
    augroup noBells
        autocmd!
        autocmd GUIEnter * set vb t_vb=
        autocmd VimEnter * set vb t_vb=
    augroup END
endif

set switchbuf=usetab
set shortmess+=a
set autowriteall
set autoread

set confirm
set backspace=indent,eol,start

set virtualedit+=all


set modeline

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" UI OPTIONS                                                               {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
augroup colorcolumn
    autocmd!
    autocmd BufNewFile,BufWinEnter * let &colorcolumn = (&textwidth == 0 ? 0 : &textwidth + 1)
augroup END
set number
set relativenumber
set showcmd
set lazyredraw
set laststatus=2
set list
set listchars=trail:·,tab:»·,extends:▶,precedes:◀

" Maximize Window on Startup
if has ("gui_running")
    if has("autocmd") && s:has_windows
        augroup windowsgui:
            autocmd!
            autocmd GUIEnter * simalt ~x " maximize in windows
        augroup END
    else
    endif
endif

" Highlight TODO, FIXME, NOTE, etc.
if has("autocmd")
    if v:version > 701
        augroup todo
            autocmd!
            autocmd Syntax * call matchadd('Debug',  '\v\W\zs<(TODO|TODO_F|FIXME|CHANGED|XXX|BUG|HACK|TRICKY)>')
            autocmd Syntax * call matchadd('Debug', '\v\W\zs<(NOTE|INFO|IDEA)>')
        augroup END
    endif
endif

" gui settings {{{2
if has ("gui_running")
    "Make GVim more like Terminal Vim
    set guioptions-=T "remove toolbar
    set guioptions-=r "remove right-hand scroll bar
    set guioptions-=l "remove right-hand scroll bar
    set guioptions=c "makes dialogs boxes appear like they do in console vim

    "Set Font
    if s:has_windows
        set guifont=DejaVu_Sans_Mono_For_Powerline:h10:cANSI
        "set guifont=DejaVu_Sans_Mono:h10:cANSI,Lucida_Console:h9:cANSI,Consolas:h9:cANSI
    elseif has('mac')
        set guifont=DejaVu\ Sans\ Mono\ For\ Powerline:h11
        " set guifont=Monaco:h12
    elseif has('unix') && !has('mac') "linux
        set guifont=DejaVu\ Sans\ Mono\ 10
    endif
endif

set background=dark
"}}}2

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" MAPPINGS & COMMANDS                                                      {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set ttimeout
set ttimeoutlen=100

set updatetime=1000

let mapleader="\<Space>"
nnoremap [myleader] <Nop>
xnoremap [myleader] <Nop>
nmap go [myleader]
xmap go [myleader]

cnoremap [cmdleader] <Nop>
cmap <C-j> [cmdleader]

set grepprg=ack\ -H\ --nocolor\ --nogroup

command! -nargs=+ Grep call s:grep(<q-args>)
function! s:grep(args) abort
    execute 'silent grep! ' . a:args
    redraw!
    execute "normal! /<C-l>"
endfunction

" Navigation
" make navigation more intuitive
nnoremap <expr> k (v:count == 0 ? 'gk' : 'k')
nnoremap <expr> j (v:count == 0 ? 'gj' : 'j')
nnoremap gk k
nnoremap gj j

" replace selection with spaces and enter replace mode
xnoremap gr r<space>gvo<esc>R

nnoremap s$ :set hlsearch<CR>:redraw<CR>:substitute///gc<Left><Left><Left>
nnoremap sG :set hlsearch<CR>:redraw<CR>:.,$substitute///gc<Left><Left><Left>
nnoremap sae :set hlsearch<CR>:redraw<CR>:%substitute///gc<Left><Left><Left>

"go to the next number
nnoremap <silent> g<C-a> /\d\+<CR>
"go to the previous number
nnoremap <silent> g<C-x> ?\d\+<CR>

" list spelling corrections
nnoremap sl viW<Esc>a<C-x><C-s><C-p>
map [sl [ssl
map ]sl ]ssl

" underline current selection with character of choice
nnoremap <silent> _ :call <SID>under_line()<CR>
function! s:under_line() abort
    let char = escape(nr2char(getchar()), '\')
    normal! yyp
    execute ':s#\m\S.*\S\|\S#\=repeat(''' . char . ''',strlen(submatch(0)))#g'
endfunction

" format wile in insert mode
inoremap <C-F> <ESC>gw{zea

nnoremap <expr> <C-W><C-T> (winnr('$') != 1 ? "<C-W>TgT" : "")

" think of "co" as "change option"
nnoremap como :<C-U>set modifiable!<CR>:set modifiable?<CR>
nnoremap coro :<C-U>set readonly!<CR>:set readonly?<CR>
nnoremap cotw :<C-U>set textwidth=
nnoremap cocl :<C-U>setlocal conceallevel=
nnoremap cosw :<C-U>set shiftwidth=
nnoremap <silent> conf :<C-U>call <SID>scratch_toggle()<CR>
function! s:scratch_toggle() abort
    if match(&buftype, '\C\v'.'nofile') != -1
        set buftype-=nofile
    else
        set buftype+=nofile
    endif
endfunction

" update diff with a key mapping
nnoremap du :diffupdate<CR>

" reselect pasted or last changed text
nnoremap <expr> gvp '`[' . strpart(getregtype(), 0, 1) . '`]'

" redraw even harder
nnoremap <silent><C-l> :redraw!<CR><C-l>

" open my vimrc
nnoremap [myleader]rc :e $MYVIMRC<CR>

nnoremap <C-W>d :bd<CR>

" make more undoes possible after leaving insert mode
inoremap <C-u> <C-g>u<C-u>
inoremap <C-w> <C-g>u<C-w>
inoremap <BS> <C-g>u<BS>
inoremap <Del> <C-g>u<Del>
inoremap <END> <C-g>u<END>

" yank to end of line, kinda like D or C
noremap Y y$

" visual selection text object
xnoremap a/ gn
onoremap a/ gn
xnoremap i/ gn
onoremap i/ gn
xnoremap i? gN
onoremap i? gN
xnoremap a? gN
onoremap a? gN

" disable Ex mode key and use it to repeat the last q macro (love this)
nnoremap Q @q
" replay q macro for each line of a visual selection
xnoremap Q :normal! @q<CR>
" repeat last command for each line of a visual selection
xnoremap . :normal! .<CR>
" repeat last command then go to the next search position
nnoremap <C-n> n.
" repeat last command then go to the previouse search position
nnoremap <C-p> N.
" repeat last command-line command
nnoremap g. @:

" split line here
function! s:split()
    s/\v(.{-})(\s*)(%#)(\s*)(.*)/\1\r\3\5
    call histdel("/", -1)
    normal! ==
endfunction
nnoremap <silent> S :call <SID>split()<CR>


" split line here
function! s:split_up()
    s/\v(.{-})(\s*)(%#)(\s*)(.*)/\3\5\r\1
    call histdel("/", -1)
    normal! k==
endfunction
nnoremap <silent> <C-s> :call <SID>split_up()<CR>

" split line here
function! s:join_front()
    s/\v(.*)\n(.*)/\2 \1
    call histdel("/", -1)
    normal! ==
endfunction
" join to front
nnoremap <C-j> :call <SID>join_front()<CR>

" set path to present working directory locally
nnoremap cdl :lcd! %:h<CR>:pwd<CR>
nnoremap cd :cd! %:h<CR>:pwd<CR>

nnoremap <leader>qa :qa!<CR>
nnoremap <leader>q :q!<CR>

" navigation in command line
cnoremap <C-p> <UP>
cnoremap <C-n> <DOWN>
cnoremap <C-h> <LEFT>
cnoremap <C-l> <RIGHT>
cnoremap <C-a> <HOME>
cnoremap <C-e> <END>

" find files easier
nnoremap <leader>e :e **/*
nnoremap <leader>f :find *
nnoremap <leader>eo :e <C-r>=expand('%<')<CR>.


" fn filename (trail) (foo.txt)
" fp absolute path  (/something/src/foo.txt)
" fP relative path  (src/foo.txt)
" ofn filename (trail)
" ofp absolute path
" ofP relative path
" dp current directory name (head) (/something/src)
" dP directory name (head) (/something/src)
" pwd current working directory
let maps = [
            \ {"str" : "fn",  "func" : "expand('%:t')"},
            \ {"str" : "fp",  "func" : "expand('%:p')"},
            \ {"str" : "fP",  "func" : "expand('%')"},
            \ {"str" : "ofn", "func" : "expand('%:t:r') . '.'"},
            \ {"str" : "ofp", "func" : "expand('%:p:r:.') . '.'"},
            \ {"str" : "ofP", "func" : "expand('%<') . '.'"},
            \ {"str" : "dp",  "func" : "expand('%:p:h')"},
            \ {"str" : "dP",  "func" : "expand('%:h')"},
            \ {"str" : "pwd", "func" : "getcwd()"}
            \ ]
for map in maps
    execute "nnoremap <silent> <Leader>y".map.str.
                \ " :let @*=".map.func.
                \ "\<CR>:let @+=".map.func.
                \ "\<CR>:let @\"=".map.func."\<CR>"
    execute "cnoremap %".map.str." \<C-r>=".map.func."\<CR>"
endfor

" accept completion (requires "set wild charm = <TAB>)
cnoremap <C-y> <SPACE><BS><TAB>

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" SCRIPTS                                                                  {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" TODO Is the word under the cursor a number?
function! DoNum(operator)
    let line = getline('.')
    let cIndex = getpos('.')[2] -1 "TODO handle virtual edit
    echom cIndex
    execute "let rLine = line[".cIndex.":]"
    echom "relavant line =".rLine
    " let rLine = substitute(rLine, '\(\d\+\|0x\x\+\)', '\=submatch(0)*10','')
    execute "let rLine = substitute(rLine, \"\(\d\+\|0x\x\+\)\", \"\=submatch(0)*10\",\"\")"
    echom rLine
    let cIndex -= 1
    execute "let line = line[:".cIndex."].rLine"
    echom line
    call setline('.', line)
endfunction

function! CalculateCursor(x, operator)
    let p = @/
    try
        silent exe "s%-\\?\d*\\%#\\d\\+%\\=submatch(0) " . a:operator . " a:x%"
        exe "normal \<C-O>"
    catch /^Vim\%((\a\+)\)\=:E486/
        try
            silent exe "normal /\\%#.\\{-}\\zs\\d\\+/b\<CR>"
            exe "s%-\\?\d*\\%#\\d\\+%\\=submatch(0) " . a:operator . " a:x%"
            exe "normal \<C-O>"
        catch /^Vim\%((\a\+)\)\=:E486/
        endtry
    finally
        let @/ = p
    endtry
endfunction

" vnoremap <silent><c-x> :<C-U>'<,'>call CalculateCursor(v:count1, "-")<CR>:noh<CR>gv
" vnoremap <silent><c-a> :<C-U>'<,'>call CalculateCursor(v:count1, "+")<CR>:noh<CR>gv
" noremap <silent>g<c-x> :<C-U>call CalculateCursor(v:count1, "*")<CR>:noh<CR>
" vnoremap <silent>g<c-x> :<C-U>'<,'>call CalculateCursor(v:count1, "*")<CR>:noh<CR>gv
" noremap <silent>g<c-a> :<C-U>call CalculateCursor(v:count1, "/")<CR>:noh<CR>
" vnoremap <silent>g<c-a> :<C-U>'<,'>call CalculateCursor(v:count1, "/")<CR>:noh<CR>gv

nnoremap <leader>m  :call SearchPosition()<CR>
nnoremap <leader>M  :let @/ = ""<CR>
function! SearchPosition()
    if @/ !~ '\v(\\\%\d+[lc](\\\|)?)+'
        let @/ = ''
        " echo "pattern didn't match = ".@/
    else
        let @/ .= '\|'
        " echo "added bar = ".@/
    endif

    let line = getpos('.')[1]
    let col = getpos('.')[2]
    execute "let @/ .= '\\%".line."l'"
    execute "let @/ .= '\\%".col."c'"
endfunction

nnoremap g** :<C-U>call AddToSearch('n')<CR>
xnoremap g* :<C-U>call AddToSearch('x')<CR>
function! AddToSearch(mode)
    let save_reg = @@
    if @/ != ''
        let @/ .= '\|'
    endif
    if a:mode == 'x'
        normal! gvy
    elseif a:mode == 'n'
        normal! yiw
    else
        let @@ = save_reg
    endif
    let @/ .= @@
    let @@ = save_reg
endfunction


command!  PreviewTagToggle call PreviewWordToggle()
nnoremap <Leader>tp :ptjump <C-r><C-w><CR>

command! -nargs=* VshSend call RunInVimShell('<Args>') "{{{2
function! RunInVimShell(cmd)
    VimShellBufferDir -popup
    execute "VimShellSendString " . a:cmd
endfunction "}}}2

" add numbers to the front or end of a line
cabbrev numend s/$/\=1-line("'<")+line(".")/c
cabbrev numfront s/^/\=1-line("'<")+line(".")/c

" Details:
" s/\d\+/ : Match one or more digits (\d\+) on any line (:%) and substitute (s).
"            \= : for each match, replace with the result of the following expression:
" printf("0x%04x", : produce a string using the format "0x%04x", which corresponds to a literal 0x followed by a four digit (or more) hex number, padded with zeros.
" submatch(0) : The result of the complete match (i.e. the number).
cabbrev tohex s/\d\+/\=printf("0x%x", submatch(0))
" find the first occurrence of a hex digit and changes it to decimal
cabbrev todec s/0x\x\+/\=printf("%d", submatch(0))
cabbrev toasc s/0x\x\+/\=printf("%c", submatch(0))
" delete the current character and replace it with it's ASCII Decimal value
nnoremap <Leader>tad xi<C-r>=printf("%d",char2nr("<C-r>""))<CR><ESC>
" delete the current character and replace it with it's ASCII Hex value
nnoremap <Leader>tah xi<C-r>=printf("0x%x",char2nr("<C-r>""))<CR><ESC>
" noremap <Leader>cs  :s/./\=printf("Ox%x + ",char2nr("submatch(0)"))/gc<CR>

" reverse selection kind of works
vnoremap <silent> <leader>is :<c-u>let old_reg_a=@a<cr>
            \:let old_reg=@"<cr>
            \gv"ay
            \:let @a=substitute(@a, '.\(.*\)\@=',
            \ '\=@a[strlen(submatch(1))]', 'g')<CR>
            \gvc<C-R>a<Esc>
            \:let @a=old_reg_a<CR>
            \:let @"=old_reg<CR>


command! -nargs=* -range=0 -bang Seq
            \ call Seq(<count>, <line1>, <line2>, <q-args>, "<bang>")

function! Seq(count, firstLine, lastLine, cmdInput, bang) abort
    "anything within backticks
    let rg_expr = '`\(.\{-1,}\)`'

    " 1 index if ! is used
    if a:bang != '!'
        let x = 0
    else
        let x = 1
    endif

    let @a = ''
    let r = ''
    for i in range(0, a:lastLine-a:firstLine) "TODO fails without a range
        let l:line = substitute(a:cmdInput, rg_expr, '\=eval(submatch(1))', 'g')
        echomsg l:line
        " call append(i+a:firstLine, line)
        let r = r.l:line."\n"
        echomsg r
        let x = x + 1
    endfor
    call setreg('a', r,  'b')
    normal! "aP
endfunction

nnoremap <silent> <leader>S  :execute ':s#\V'.escape(nr2char(getchar()), '\').'#\r#g'<CR>
nnoremap <silent> <leader>gS :execute ':s#\s*\V'.escape(nr2char(getchar()), '\').'\v\s*#\r#g'<CR>
xnoremap <silent> <leader>J  :<C-U>execute '''<,''>:s#\n#'.escape(nr2char(getchar()), '\').'#g'<CR>
xnoremap <silent> <leader>gJ :<C-U>execute '''<,''>:s#\n#'.escape(nr2char(getchar()), '\').' #g'<CR>

command! -nargs=* -range=0 -bang Split
            \ call Split(<count>, <line1>, <line2>, <q-args>, '<bang>')
function! Split(count, first_line, last_line, input, bang) abort
    let input = a:input
    if input == ''
        let input = nr2char(getchar())
    endif

    let selection = selection#new(a:count, a:first_line, a:last_line)
    if selection.content == ''
        throw 'nothing there'
    endif

    let expr_list = split(selection.content, '\n', 1)

    for i in range(len(expr_list))
        let expr_list[i] = join(split(expr_list[i], input),"\n")
    endfor

    let expr_lines = join(expr_list, "\n")
    call selection.over_write(expr_lines)
endfunction

command! -nargs=* -range=0 -bang Join
            \ call Join(<count>, <line1>, <line2>, <q-args>, '<bang>')
function! Join(count, first_line, last_line, input, bang) abort
    let input = a:input
    if input == ''
        let input = nr2char(getchar())
    endif

    let selection = selection#new(a:count, a:first_line, a:last_line)
    if selection.content == ''
        throw 'nothing there'
    endif

    let expr_list = split(selection.content, '\n', 0)

    let expr_lines = join(expr_list, input)
    call selection.over_write(expr_lines)
endfunction

function! TSIndent(line)
    return strlen(matchstr(a:line,'\v^\s+'))
endfunction

command! -nargs=* Bin echomsg s:bin_info(<q-args>)
command! -nargs=* Num echomsg s:number_info(<q-args>)
command! -nargs=* Char echomsg s:char_info(<q-args>)
command! -nargs=* Str2hex echomsg s:str_to_hex(<q-args>)
command! -nargs=* Hex2str echomsg s:hex_to_str(<q-args>)

function! s:bin2hex(bin)
    let x = {
                \ "0000" : "0",
                \ "0001" : "1",
                \ "0010" : "2",
                \ "0011" : "3",
                \ "0100" : "4",
                \ "0101" : "5",
                \ "0110" : "6",
                \ "0111" : "7",
                \ "1000" : "8",
                \ "1001" : "9",
                \ "1010" : "a",
                \ "1011" : "b",
                \ "1100" : "c",
                \ "1101" : "d",
                \ "1110" : "e",
                \ "1111" : "f"
                \ }
    let result = ""
    let number = split(a:bin, '....\zs')
    for char in number
        let result .= x[char]
    endfor
    return result
endfunction

function! s:hex2bin(number)
    let x = {
                \ "0" : "0000",
                \ "1" : "0001",
                \ "2" : "0010",
                \ "3" : "0011",
                \ "4" : "0100",
                \ "5" : "0101",
                \ "6" : "0110",
                \ "7" : "0111",
                \ "8" : "1000",
                \ "9" : "1001",
                \ "a" : "1010",
                \ "b" : "1011",
                \ "c" : "1100",
                \ "d" : "1101",
                \ "e" : "1110",
                \ "f" : "1111"
                \ }
    let result = ""
    let number = split(a:number, '.\zs')
    for char in number
        let result .= x[char]
    endfor
    return result
endfunction

function! s:hex_to_str(hex_str)
    let separator = nr2char(getchar())
    let hex_str = substitute(a:hex_str, separator, "", "ge")

    let str = ""
    for i in range(len(hex_str)/2)
        let str .= nr2char("0x" . strpart(hex_str, i*2, 2))
    endfor
    return  str
endfunction

function! s:str_to_hex(str)
    let separator = nr2char(getchar())

    if separator == ""
        let separator = ""
    endif

    let hex_str = ""
    for i in range(len(a:str))

        if(i == len(a:str) - 1)
            let separator = ""
        endif

        let hex_str = hex_str . printf("%02x", char2nr(a:str[i])) . separator
    endfor

    return  toupper(hex_str)
endfunction

function! s:bin_info(bin)
    let hex = s:bin2hex(a:bin)
    let number = eval("0x" . hex)
    let char = nr2char(number)
    let bin = a:bin
    return printf("%d, 0x%02x, '%s' 0b%s", number, number, char, bin)
endfunction

function! s:char_info(char) abort
    let number = char2nr(a:char)
    let char = a:char
    let bin = s:hex2bin(printf("%02x", number))
    return printf("%d, 0x%02x, '%s', 0b%s", number, number, char, bin)
endfunction

function! s:number_info(number) abort
    let number = eval(a:number)
    let char = nr2char(number)
    let bin = s:hex2bin(printf("%02x", number))
    return printf("%d, 0x%02x, '%s', 0b%s", number, number, char, bin)
endfunction

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" BEFORE PLUGINS                                                           {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if filereadable('.vimrc_project')
    source .vimrc_project
endif

if filereadable(glob('~/.vimrc_local', 1))
    source ~/.vimrc_local
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" PLUGINS                                                                  {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" neobundle {{{2

let s:neobundle_path = s:vim_path.'/bundle/neobundle.vim'
if !isdirectory(s:neobundle_path)
    execute '!git clone https://github.com/Shougo/neobundle.vim '
        \ . s:neobundle_path
endif
if has('vim_starting')
    execute 'set runtimepath+='.s:neobundle_path.'/'
endif

call neobundle#begin(expand(s:vim_path.'/bundle'))
" Let NeoBundle manage NeoBundle
NeoBundleFetch 'Shougo/neobundle.vim' "}}}2

" vimproc.vim {{{2
NeoBundle 'Shougo/vimproc.vim', {
            \ 'build' : {
            \     'windows' : 'make -f make_mingw32.mak',
            \     'cygwin' : 'make -f make_cygwin.mak',
            \     'mac' : 'make -f make_mac.mak',
            \     'unix' : 'make -f make_unix.mak',
            \    },
            \ } "}}}2

" text objects {{{2
NeoBundle 'kana/vim-textobj-user'
NeoBundle 'saihoooooooo/vim-textobj-space'
NeoBundle 'Julian/vim-textobj-variable-segment'
NeoBundle 'coderifous/textobj-word-column.vim'
NeoBundle 'kana/vim-textobj-entire'
NeoBundle 'kana/vim-textobj-indent'
NeoBundle 'kana/vim-textobj-line'
NeoBundle 'mattn/vim-textobj-url'
NeoBundle 'glts/vim-textobj-comment'
NeoBundle 'thinca/vim-textobj-between'
NeoBundle 'osyo-manga/vim-textobj-multiblock'
"}}}2

" unite {{{2
NeoBundle 'Shougo/unite.vim'
NeoBundle 'Shougo/unite-ssh'
NeoBundle 'Shougo/unite-outline'
NeoBundle 'Shougo/unite-session'
NeoBundle 'Shougo/neomru.vim'
NeoBundle 'tsukkee/unite-help'
NeoBundle 'ujihisa/unite-colorscheme'
NeoBundle 'kmnk/unite-command'
NeoBundle 'majkinetor/unite-cmdmatch'
NeoBundle 'voi/unite-ctags'
NeoBundle 'tsukkee/unite-tag'
NeoBundle 'thinca/vim-unite-history'
NeoBundle 'kopischke/unite-spell-suggest'
NeoBundle 'kmnk/vim-unite-giti'
NeoBundle 'hewes/unite-gtags'
NeoBundle 'naquad/unite-digraphs' "}}}2

" NeoBundle 'rhysd/vim-operator-surround' , {'depends' : 'kana/vim-operator-user'}
NeoBundle 'kana/vim-operator-replace' , {'depends' : 'kana/vim-operator-user'}
NeoBundle 'tpope/vim-surround'
NeoBundle 'tommcdo/vim-exchange'
NeoBundle 'tpope/vim-commentary'
NeoBundle 'tpope/vim-repeat' "}}}2

" NeoBundle 'Shougo/neocomplcache'
NeoBundle 'altercation/vim-colors-solarized'
NeoBundle 'AndrewRadev/linediff.vim'
NeoBundle 'arecarn/crunch.vim', {'depends' : 'arecarn/selection.vim'}
NeoBundle 'arecarn/auto-file-loader.vim'
NeoBundle 'arecarn/clean-fold.vim'
NeoBundle 'arecarn/fold-cycle.vim' ",  {'rev' : 'topics/global_fold_cycling'}
NeoBundle 'arecarn/frisk.vim'
NeoBundle 'dbeniamine/todo.txt-vim'

NeoBundle 'diffchanges.vim'
NeoBundle 'arecarn/git-diff-cached-preview.vim'
NeoBundle 'arecarn/go-to-buffer.vim'
NeoBundle 'arecarn/mixed-case-operator.vim'
NeoBundle 'arecarn/spell-utils.vim'
NeoBundle 'arecarn/diff-utils.vim'
NeoBundle 'arecarn/Preserve.vim' "TODO Merge into the true one
NeoBundle 'arecarn/templates'
NeoBundle 'bling/vim-airline'
NeoBundle 'chreekat/vim-paren-crosshairs'
NeoBundle 'chrisbra/vim-diff-enhanced'
NeoBundle 'dbakker/vim-lint'
NeoBundle 'dhruvasagar/vim-table-mode'
NeoBundle 'edkolev/tmuxline.vim'
NeoBundle 'godlygeek/tabular'
NeoBundle 'gregsexton/gitv'
NeoBundle 'cohama/agit.vim'
" NeoBundle 'henrik/vim-qargs'
NeoBundle 'hrsh7th/vim-neco-calc'
NeoBundle 'idanarye/vim-vebugger', {'depends' : 'shougo/vimproc.vim'}
NeoBundle 'int3/vim-extradite'
NeoBundle 'junegunn/goyo.vim'
NeoBundle 'junegunn/vader.vim'
NeoBundle 'junegunn/vim-oblique' , {'depends' : 'junegunn/vim-pseudocl'}
NeoBundle 'kana/vim-niceblock'
" NeoBundle 'Lokaltog/vim-easymotion'
NeoBundle 'lopter/moin.vim'
NeoBundle 'mbbill/undotree'
NeoBundle 'morhetz/gruvbox'
NeoBundle 'nathanaelkane/vim-indent-guides'
NeoBundle 'roman/golden-ratio'
NeoBundle 'scrooloose/syntastic'
NeoBundle 'Shougo/echodoc.vim'
NeoBundle 'Shougo/neocomplete'
NeoBundle 'Shougo/neosnippet-snippets'
NeoBundle 'Shougo/neosnippet.vim'
NeoBundle 'Shougo/vimfiler.vim', {'depends' : 'Shougo/unite.vim'}
NeoBundle 'Shougo/vimshell.vim', {'depends' : 'Shougo/vimproc.vim'}
NeoBundle 't9md/vim-choosewin'
NeoBundle 't9md/vim-quickhl'
NeoBundle 't9md/vim-textmanip'
NeoBundle 'talek/obvious-resize'
" NeoBundle 'TeTrIs.vim'
NeoBundle 'thinca/vim-qfreplace'
" NeoBundle 'tommcdo/vim-lion'
NeoBundle 'tpope/vim-abolish'
" NeoBundle 'tpope/vim-dispatch'
NeoBundle 'tpope/vim-eunuch'
NeoBundle 'tpope/vim-fugitive'
NeoBundle 'tpope/vim-markdown'
NeoBundle 'tpope/vim-scriptease'
NeoBundle 'tpope/vim-speeddating'
NeoBundle 'tpope/vim-unimpaired'
NeoBundle 'vim-scripts/cmdalias.vim'
" NeoBundle 'vim-scripts/DrawIt'
NeoBundle 'vim-scripts/FormatToWidth', {'depends' : 'vim-scripts/ingo-library'}
NeoBundle 'vim-scripts/scons.vim'
NeoBundle 'vim-scripts/UnconditionalPaste'
" NeoBundle 'w0ng/vim-hybrid'
NeoBundle 'mhinz/vim-signify'
NeoBundle 'qstrahl/vim-matchmaker'
" NeoBundle 'AndrewRadev/gapply.vim'
" NeoBundle 'tomtom/tassert_vim'
" NeoBundle 'Decho'
" NeoBundle 'lyuts/vim-rtags'
" NeoBundle 'sickill/vim-monokai'
" NeoBundle 'mhinz/vim-sayonara'
NeoBundle 'airblade/vim-rooter'
NeoBundle 'wesQ3/vim-windowswap'
NeoBundle 'dyng/ctrlsf.vim'
NeoBundle 'ludovicchabant/vim-gutentags'
call neobundle#end()
NeoBundleCheck
filetype plugin indent on

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" PLUGINS CONFIG                                                           {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" netrw {{{2
" set up line numebring and other good stuff
let g:netrw_bufsettings = 'noma nomod rnu nobl nowrap ro'
" hide .swp .o12 .dbg .lst files in explorer
let g:netrw_list_hide= '.*\.swp$,.*\.o12$,.*\.dbg$,.*\.lst'
" netrw }}}2

if neobundle#is_installed('neocomplcache') "{{{2
    if !isdirectory(s:vim_path.'/utils_local/neocomplcache')
        call mkdir(s:vim_path.'/utils_local/neocomplcache', "p", 0700)
    endif
    let g:neocomplcache_temporary_dir = s:vim_path.'/utils_local/neocomplcache'
    let g:neocomplcache_enable_at_startup = 1
    let g:neocomplcache_enable_smart_case = 1
    let g:neocomplcache_enable_camel_case_completion = 1
    let g:neocomplcache_enable_underbar_completion = 1
    let g:neocomplcache_min_syntax_length = 2
    let g:neocomplcache_lock_buffer_name_pattern = '\*ku\*'
    let g:neocomplcache_enable_auto_delimiter = 1
    let g:neocomplcache_max_list = 100

    let g:neocomplcache_dictionary_filetype_lists = {
                \ 'default' : '',
                \ 'vimshell' : s:vim_path.'/.vimshell_hist',
                \ 'scheme' : s:vim_path.'/.gosh_completions'
                \ }

    " Define keyword, for minor languages
    if !exists('g:neocomplcache_keyword_patterns')
        let g:neocomplcache_keyword_patterns = {}
    endif
    let g:neocomplcache_keyword_patterns['default'] = '\h\w*'


    " Recommended key-mappings.
    " <CR>: close popup and save indent.
    inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
    function! s:my_cr_function()
        " return neocomplcache#smart_close_popup() . "\<CR>"
        return pumvisible() ? neocomplcache#close_popup() : "\<CR>"
    endfunction
    " <TAB>: completion.
    inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"

    " Enable heavy omni completion.
    " if !exists('g:neocomplcache_omni_patterns')
    "     let g:neocomplcache_omni_patterns = {}
    " endif
    " let g:neocomplcache_omni_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
    " let g:neocomplcache_omni_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
    " let g:neocomplcache_omni_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
    " let g:neocomplcache_omni_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
    " let g:neocomplcache_omni_patterns.ruby = '[^. *\t]\.\h\w*\|\h\w*::'
    " nnoremap conc :NeoComplCacheToggle<CR>
endif "}}}2

if neobundle#is_installed('neocomplete') "{{{2
    " Use neocomplete.
    let g:neocomplete#enable_at_startup = 1

    augroup NEOCOMPLETE
        autocmd!
        " autocmd BufRead * NeoCompleteLock
        autocmd FileType gitcommit let g:neocomplete#enable_auto_close_preview = 0
    augroup END

    nnoremap conc :NeoCompleteToggle<CR>

    let g:neocomplete#disable_auto_complete = 0
    let g:neocomplete#enable_smart_case = 1
    let g:neocomplete#enable_camel_case = 1
    let g:neocomplete#enable_under_bar = 1
    let g:neocomplete#enable_auto_delimiter = 1
    let g:neocomplete#sources#syntax#min_keyword_length = 4
    let g:neocomplete#sources#tags#cache_limit_size = 5000000000000000.0
    let g:neocomplete#max_list = 20

    if !isdirectory(s:vim_path.'/utils_local/neocomplete')
        call mkdir(s:vim_path.'/utils_local/neocomplete', "p", 0700)
    endif
    let g:neocomplete#data_directory = s:vim_path.'/utils_local/neocomplete/'

    " Define dictionary.
    let g:neocomplete#sources#dictionary#dictionaries = {
                \ 'default' : '',
                \ 'vimshell' : $HOME.'/.vimshell_hist',
                \ 'scheme' : $HOME.'/.gosh_completions'
                \ }

    " Define keyword.
    if !exists('g:neocomplete#keyword_patterns')
        let g:neocomplete#keyword_patterns = {}
    endif
    let g:neocomplete#keyword_patterns['default'] = '\h\w*'

    " Plugin key-mappings
    inoremap <expr><C-g> neocomplete#undo_completion()

    " Recommended key-mappings.
    " <CR>: close popup and save indent.
    inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
    function! s:my_cr_function()
        return neocomplete#close_popup() . "\<CR>"
    endfunction

    " For smart TAB completion.
    inoremap <expr><TAB>  pumvisible() ? "\<C-n>" :
                \ <SID>check_back_space() ? "\<TAB>" :
                \ neocomplete#start_manual_complete()
    function! s:check_back_space() "{{{
        let col = col('.') - 1
        return !col || getline('.')[col - 1]  =~ '\s'
    endfunction

    inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
    inoremap <expr><C-y>  neocomplete#close_popup()
    inoremap <expr><C-e>  neocomplete#cancel_popup()

    " Enable omni completion.
    autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
    autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
    autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
    autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
    autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

    " Enable heavy omni completion.
    if !exists('g:neocomplete#sources#omni#input_patterns')
        let g:neocomplete#sources#omni#input_patterns = {}
    endif
    let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
    let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
    let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

    " For perlomni.vim setting.
    " https://github.com/c9s/perlomni.vim
    let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
endif "}}}2

if neobundle#is_installed('neosnippet-snippets') "{{{2
    imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
                \ "\<Plug>(neosnippet_expand_or_jump)":
                \  pumvisible() ? "\<C-n>" :
                \ <SID>check_back_space() ? "\<TAB>" :
                \ neocomplete#start_manual_complete()

    function! s:check_back_space() "{{{
        let col = col('.') - 1
        return !col || getline('.')[col - 1]  =~ '\s'
    endfunction

    smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
                \ "\<Plug>(neosnippet_expand_or_jump)"
                \: "\<TAB>"

    if has('conceal')
        set conceallevel=2 concealcursor=i
    endif

    let g:neosnippet#snippets_directory=s:vim_path.'/utils/snippets'
endif "}}}2

if neobundle#is_installed('unite.vim') "{{{2
    let g:unite_data_directory = s:vim_path.'/utils_local/unite/'
    let g:unite_winheight = 10
    let g:unite_source_history_yank_enable = 1
    let g:unite_source_history_yank_limit = 100
    let g:unite_split_rule = 'botright'
    call unite#filters#matcher_default#use(['matcher_fuzzy'])
    call unite#filters#sorter_default#use(['sorter_rank'])
    call unite#custom#source('file_rec/git,file_rec,file_rec/async', 'max_candidates', 0)
    call unite#custom#profile('files', 'filters', 'sorter_rank')
    let s:unite_sources = 'file_rec/git,file_rec,file_rec/async,file_mru,file,grep'
    call unite#custom#source(
                \ s:unite_sources,
                \ 'ignore_pattern',
                \ join(
                \     [
                \      '\.git.*',
                \      '\.hg.*',
                \      '\.svn.*',
                \      '\.Trash*',
                \      '*.ini',
                \      '*.dbx',
                \      '*.cache',
                \      'tags.*',
                \     ],
                \     '\|'
                \ ))

    let s:unite_ignore_globs = &wildignore.','.substitute(&suffixes, '\.', '*.', 'g')
    call unite#custom#source(
                \ s:unite_sources,
                \ 'ignore_globs',
                \ split(s:unite_ignore_globs, ',')
                \ )

    let s:unite_grep_excludes = substitute(s:unite_ignore_globs, '^\|,', ' --exclude=', 'g')
    let g:unite_grep_excludes  = s:unite_grep_excludes
    let g:unite_source_grep_command = 'grep'
    let g:unite_source_grep_default_opts = '-InHPR ' . ' --exclude-dir={.git,.hg,.svn}'
    "                                        |||||
    " -I ignore binary files-----------------+||||
    " -n print line numbers-------------------+|||
    " -H print filename with match--------------||
    " -P perl regex-----------------------------+|
    " -R Recursive-------------------------------+

    augroup unite
        autocmd!
        autocmd FileType unite call s:unite_settings()
    augroup END
    function! s:unite_settings()
        nnoremap <silent><buffer><expr> <C-s> unite#do_action('split')
        nnoremap <silent><buffer><expr> <C-v> unite#do_action('vsplit')
        nnoremap <silent><buffer><expr> <C-t> unite#do_action('tabopen')
        nnoremap <silent><buffer><expr> <C-g> unite#do_action('goto')
    endfunction
    let g:unite_source_menu_menus = {}
    let g:unite_source_menu_menus.interpreters = {
                \     'description' : 'Interpreter Menu',
                \ }
    let g:unite_source_menu_menus.interpreters.command_candidates = [
                \   ['VimShell', 'VimShell -split'],
                \   ['bc', 'VimShellInteractive bc'],
                \   ['octave', 'VimShellInteractive octave'],
                \   ['python', 'VimShellInteractive python'],
                \   ['ipython', 'VimShellInteractive ipython --colors=NoColor'],
                \ ]

    xnoremap [myleader]g  y:<C-u>Unite -no-quit grep:.<CR><C-r>=escape(expand(@@), ' ')<CR><CR>
    nnoremap [myleader]g  :<C-u>Unite -no-quit grep:.<CR>
    nnoremap [myleader]gw :<C-u>UniteWithCursorWord -no-quit grep:.<CR>
    nnoremap [myleader]f :<C-u>Unite file_rec/git file_rec/async -start-insert -unique -input=<CR>
    nnoremap [myleader]r  :<C-u>Unite file_mru -start-insert<CR>
    nnoremap [myleader]rg :<C-u>Unite register -vertical<CR>
    nnoremap [myleader]b  :<C-u>Unite buffer:! -start-insert<CR>
    nnoremap [myleader]o  :<C-u>Unite outline<CR>
    nnoremap [myleader]l  :<C-u>Unite line -start-insert<CR>
    nnoremap [myleader]h  :<C-u>Unite help -start-insert<CR>
    nnoremap [myleader]s  :<C-u>Unite -input=session<CR>
    nnoremap [myleader]i  :<C-u>Unite menu:interpreters<CR>
    nnoremap [myleader]hc :<C-u>Unite cmdmatch history/command<CR>
    nnoremap [myleader]hs :<C-u>Unite history/search<CR>
    nnoremap [myleader]p  :<C-u>Unite history/yank<CR>
    xnoremap [myleader]p  dk:<C-u>Unite history/yank<CR>
    nnoremap [myleader]ps :<C-u>Unite process -start-insert<CR>
    nnoremap [myleader]up :<C-u>Unite neobundle/update -tab<CR>
    nnoremap [myleader]t  :<C-u>UniteWithCursorWord tag<CR>
    nnoremap [myleader]ur :<C-u>UniteResume<CR>
    nnoremap [myleader]gs  :<C-u>Unite spell_suggest<CR>
    command! Messages Unite output:message
    command! Digraphs Unite digraphs

    " toggle the preview window when I press the "p" key.
    autocmd FileType unite call s:unite_my_settings()
    function! s:unite_my_settings()
        nnoremap <silent><buffer><expr> p
                    \ empty(filter(range(1, winnr('$')),
                    \ 'getwinvar(v:val, "&previewwindow") != 0')) ?
                    \ unite#do_action('preview') : ":\<C-u>pclose!\<CR>"
        nnoremap <silent><buffer><expr> O unite#do_action('persist_open')
    endfunction
    let g:neocomplcache_tags_caching_limit_file_size = 5000000000000000.0

endif "}}}2

if neobundle#is_installed('vimfiler.vim') "{{{2
    " Replace entry commands with Vim filer
    let g:loaded_netrw = 1
    let g:loaded_netrwPlugin = 1
    let g:vimfiler_as_default_explorer = 1

    command! -nargs=* Explore :VimFilerBufferDir <Args>
    command! -nargs=* Sexplore :VimFilerBufferDir -split -horizontal <Args>
    command! -nargs=* Vexplore :VimFilerBufferDir -split  <Args>
    command! -nargs=* Texplore :VimFilerBufferDir -tab <Args>
endif "}}}2

if neobundle#is_installed('vimshell.vim') "{{{2
    nnoremap <silent> [myleader]sh
                \ :<C-u>topleft 15split<CR>:<C-u>VimShellCurrentDir<CR>

    nnoremap <silent> [myleader]shv
                \ :<C-u>vsplit<CR>:<C-u>VimShellCurrentDir<CR>

    nnoremap <silent> [myleader]shs
                \ :<C-u>split<CR>:<C-u>VimShellCurrentDir<CR>

    let g:vimshell_enable_start_insert = 1
    let g:vimshell_vimshrc_path = s:vim_path.'/utils/vimshell/vimshellrc'

    if !isdirectory(s:vim_path.'/utils_local/vimshell')
        call mkdir(s:vim_path.'/utils_local/vimshell', "P", 0700)
    endif
    let g:vimshell_data_directory = s:vim_path.'/utils_local/vimshell/'
    let g:vimshell_editor_command = 'gvim'
endif "}}}2

if neobundle#is_installed('echodoc.vim') "{{{2
    let g:echodoc_enable_at_startup=1
    set cmdheight=2
endif "}}}2

if neobundle#is_installed('vim-oblique') "{{{2
    let g:oblique#incsearch_highlight_all = 1
endif "}}}2

if neobundle#is_installed('vim-fugitive') "{{{2
    nnoremap <Leader>gs :Gstatus<CR>
    nnoremap <Leader>gd :Gdiff<CR>
    nnoremap <Leader>gc :Gcommit<CR>
    nmap <Leader>gj <C-W>P<C-N>D
    nmap <Leader>gk <C-W>P<C-P>D
endif "}}}2

if neobundle#is_installed('frisk.vim') "{{{2
    call frisk#AddEngine('yahoo', 'http://search.yahoo.com/search?p=')

    command! Rfrisk call ReloadFrisk()
    "Do the stuff for frisk
    function! ReloadFrisk()
        Runtime ~/Dropbox/projects/frisk/gc/frisk/plugin/*.vim
        Runtime ~/Dropbox/projects/frisk/gc/frisk/autoload/*.vim
        Runtime ~/Dropbox/projects/frisk/gc/frisk/autoload/frisk/*.vim
    endfunction
endif "}}}2

if neobundle#is_installed('tabular') "{{{2
    nnoremap <Leader>a :Tabularize/
    xnoremap <Leader>a :Tabularize/
endif "}}}2

if neobundle#is_installed('vim-indent-guides') "{{{2
    nmap <silent> coig <Plug>IndentGuidesToggle
    let g:indent_guides_enable_on_vim_startup = 0
    let g:indent_guides_default_mapping = 0
    let g:indent_guides_guide_size = 1
    let g:indent_guides_start_level = 2
endif "}}}2

if neobundle#is_installed('syntastic') "{{{2
    let g:syntastic_check_on_open = 0
    let g:syntastic_python_checkers = ['python']
    nnoremap cost :SyntasticToggleMode<CR>
endif "}}}2

if neobundle#is_installed('vim-textmanip') "{{{2
    xmap <C-j> <Plug>(textmanip-move-down)
    xmap <C-k> <Plug>(textmanip-move-up)
    xmap <C-h> <Plug>(textmanip-move-left)
    xmap <C-l> <Plug>(textmanip-move-right)

    xmap g<C-j> <Plug>(textmanip-duplicate-down)
    xmap g<C-k> <Plug>(textmanip-duplicate-up)
    xmap g<C-h> <Plug>(textmanip-duplicate-left)
    xmap g<C-l> <Plug>(textmanip-duplicate-right)

    xmap gb<C-j> <Plug>(textmanip-blank-below)
    xmap gb<C-k> <Plug>(textmanip-blank-above)

    " toggle insert/replace with
    nmap cotm <Plug>(textmanip-toggle-mode)
endif "}}}2

if neobundle#is_installed('vim-quickhl') "{{{2
    nmap m <Plug>(quickhl-manual-this)
    nnoremap gm m
    nnoremap gm m
    xmap m <Plug>(quickhl-manual-this)
    nmap M <Plug>(quickhl-manual-reset)
    xmap M <Plug>(quickhl-manual-reset)
endif "}}}2

if neobundle#is_installed('vim-easymotion') "{{{2
    map <Nop> <Plug>(easymotion-prefix)
    map g/ <Plug>(easymotion-sn)
    map g? <Plug>(easymotion-sn)

    let g:EasyMotion_smartcase = 1
    let g:EasyMotion_do_mapping = 0
endif "}}}2

if neobundle#is_installed('vim-choosewin') "{{{2
    nmap <C-w>? <Plug>(choosewin)
    let g:choosewin_overlay_enable = 1
    let g:choosewin_overlay_clear_multibyte = 1
    let g:choosewin_statusline_replace = 0
endif "}}}2

if neobundle#is_installed('cmdalias.vim') "{{{2
    command! Pwf echo expand('%:p')
    augroup VIMRC_aliases
        autocmd!
        autocmd VimEnter * Alias pwf Pwf
        autocmd VimEnter * Alias ex Explore
        autocmd VimEnter * Alias sex Sexplore
        autocmd VimEnter * Alias tex Texplore
        autocmd VimEnter * Alias vex Vexplore
    augroup END
endif "}}}2

if neobundle#is_installed('FormatToWidth') "{{{2
    xmap gQ <Plug>FormatToWidth
endif "}}}2

if neobundle#is_installed('linediff.vim') "{{{2
    xnoremap <Leader>ld :Linediff<CR>
endif "}}}2

if neobundle#is_installed('vim-textobj-between') "{{{2
    if neobundle#is_installed('vim-textobj-between')
        let g:textobj_between_no_default_key_mappings = 1
        xmap am <Plug>(textobj-between-a)
        omap am <Plug>(textobj-between-a)
        xmap im <Plug>(textobj-between-i)
        omap im <Plug>(textobj-between-i)
    endif
endif "}}}2

if neobundle#is_installed('vim-textobj-comment') "{{{2
    let g:textobj_comment_no_default_key_mappings = 1
    xmap a# <Plug>(textobj-comment-a)
    omap a# <Plug>(textobj-comment-a)
    xmap i# <Plug>(textobj-comment-i)
    omap i# <Plug>(textobj-comment-i)
endif "}}}2

if neobundle#is_installed('vim-table-mode') "{{{2
    let g:table_mode_separator = '|'
endif "}}}2

if neobundle#is_installed('undotree') "{{{2
    nnoremap [myleader]ut :UndotreeToggle<CR>:UndotreeFocus<CR>
endif "}}}2

if neobundle#is_installed('goyo.vim') "{{{2
    nnoremap cof :<C-U>setlocal wrap<CR>:<C-U>call SetGoyo(v:count)<CR>
    function! SetGoyo(num)
        if a:num == 0
            Goyo
        else
            execute "Goyo ".string(a:num)
        endif
    endfunction
endif "}}}2

if neobundle#is_installed('scons.vim') "{{{2
    augroup SCONS
        autocmd!
        autocmd BufNewFile,BufRead SCons*,scons* set filetype=scons
    augroup END
endif "}}}2

if neobundle#is_installed('obvious-resize') "{{{2
    "map F9 - F12 (like hjkl) to resize windows
    nnoremap  <silent><F9>  :ObviousResizeLeft<CR>
    nnoremap  <silent><F10> :ObviousResizeDown<CR>
    nnoremap  <silent><F11> :ObviousResizeUp<CR>
    nnoremap  <silent><F12> :ObviousResizeRight<CR>
endif "}}}2

if neobundle#is_installed('Preserve.vim') "{{{2
    command! -range=% Dtrail :PreserveSave|<line1>,<line2>s,\s\+$,,ge|PreserveRestore
    nnoremap <silent><leader>dt :Dtrail<CR>
    nnoremap =ae :call Preserve("normal! gg=G")<CR>
    nnoremap =ie :call Preserve("normal! gg=G")<CR>
    nnoremap yae :call Preserve("normal! ggyG")<CR>
    nnoremap yie :call Preserve("normal! ggyG")<CR>
endif "}}}2

if neobundle#is_installed('moin.vim') "{{{2
    augroup MOIN
        autocmd!
        autocmd BufNewFile,BufRead *.moin set filetype=moin
    augroup END
endif "}}}2

if neobundle#is_installed('crunch.vim') "{{{2
    let g:crunch_user_variables = {'e': exp(1),  'pi':3.14159265359}

    command! Rcrunch call ReloadCrunch()
    " Do the stuff for crunch
    function! ReloadCrunch()
        Runtime ~/Dropbox/projects/crunch/crunch/plugin/*.vim
        Runtime ~/Dropbox/projects/crunch/crunch/autoload/*.vim
        Runtime ~/Dropbox/projects/crunch/crunch/autoload/crunch/*.vim
    endfunction

    " do crunch tests
    if s:has_windows
        nnoremap <Leader>ct :!cd \Users\arecarn\Dropbox\repos\crunch\crunch\tests && gvim -u ..\.vimrc_minimal +Vader*<CR>
        nnoremap <Leader>tc :!cd \Users\arecarn\Dropbox\repos\crunch\crunch\tests && gvim -u ..\.vimrc_minimal<CR>
    else
        nnoremap <Leader>ct :!cd ~/Dropbox/repos/crunch/crunch/tests && /usr/local/bin/vim -u ../.vimrc_minimal +Vader\*<CR>
        nnoremap <Leader>tc :!cd ~/Dropbox/repos/crunch/crunch/tests && /usr/local/bin/vim -u ../.vimrc_minimal<CR>
    endif
endif "}}}2

if neobundle#is_installed('golden-ratio') "{{{2
    let g:golden_ratio_autocommand = 0
    nmap <silent> <C-w>g <Plug>(golden_ratio_resize)
endif "}}}2

if neobundle#is_installed('vim-surround') "{{{2
    " custom surround using :
    let g:surround_58 = "\1Surround\1\r\1\1"
endif "}}}2

if neobundle#is_installed('clean-fold.vim') "{{{2
    set foldmethod=expr
    set foldtext=clean_fold#fold_text_minimal()
    set foldexpr=clean_fold#fold_expr(v:lnum)
else
    set foldmethod=indent
endif "}}}2

if neobundle#is_installed('vim-matchmaker') "{{{2
    nnoremap comm :MatchmakerToggle<CR>
    augroup match_maker
        autocmd!
        autocmd Syntax,BufNewFile,BufEnter,BufRead * highlight clear Matchmaker | highlight Matchmaker term=underline cterm=reverse  gui=reverse
    augroup END
endif "}}}2

if neobundle#is_installed('vim-rooter') "{{{2
    let g:rooter_manual_only = 1
    let g:rooter_disable_map = 1
    let g:rooter_use_lcd = 0
    map <silent> cdp <Plug>RooterChangeToRootDirectory
endif "}}}2

if neobundle#is_installed('vim-unite-giti') "{{{2
    nnoremap [myleader]git :<C-u>Unite giti -start-insert<CR>
endif "}}}2

if neobundle#is_installed('fold-cycle.vim') "{{{2
   let g:fold_cycle_default_mapping = 0
   nmap zo <Plug>(fold-cycle-open)
   nmap zc <Plug>(fold-cycle-close)
   " nmap zr <Plug>(fold-cycle-open-global)
   " nmap zm <Plug>(fold-cycle-close-global)
endif "}}}2

if neobundle#is_installed('vim-operator-replace') "{{{2
    map g" <Plug>(operator-replace)
endif "}}}2

if neobundle#is_installed('gruvbox') "{{{2
    colorscheme gruvbox
endif "}}}2

if neobundle#is_installed('vim-airline') "{{{2
    let g:airline#extensions#tabline#enabled = 1
    let g:airline#extensions#tabline#tab_nr_type = 1
    let g:airline#extensions#tabline#buffer_nr_show = 1
    let g:airline_powerline_fonts = 1
    let g:airline_inactive_collapse = 0

    if neobundle#is_installed('gruvbox') "{{{3
        let g:airline_theme='gruvbox'
    endif "}}}3

    if !has('vim_starting') && g:loaded_airline
        AirlineRefresh "refresh  when it starts looking wonky
    endif
endif "}}}2

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" -                                                                        {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim: textwidth=78
" vim: foldmethod=marker
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}

" -                                                                        {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set cpoptions&vim
set encoding=utf-8 "make Vim use UTF-8 by default
scriptencoding utf-8
set fileformats=unix,dos

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" UTILITY FUNCTIONS & VARIABLES                                            {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

let s:has_tmux = ($TERM ==# 'screen' || $TERM ==# 'screen-256color') && !empty($TMUX)
let s:has_windows = has('win32') || has('win64')

if s:has_windows
    let g:path_sep = '\'
else
    let g:path_sep = '/'
endif

let g:app = has('nvim') ?  'nvim' : 'vim'

if s:has_windows
    let g:config_path = $LOCALAPPDATA . '\' . g:app . '\'
    let g:data_path   = $LOCALAPPDATA . '\' . g:app . '-data\'
    let g:cache_path  = $LOCALAPPDATA . '\' . g:app . '-cache\'
else
    if empty($XDG_CONFIG_HOME)
        let g:config_path = $HOME . '/.config/' . g:app . '/'
    else
        let g:config_path = $XDG_CONFIG_HOME . '/' . g:app . '/'
    endif

    if empty($XDG_DATA_HOME)
        let g:data_path = $HOME . '/.local/share/' . g:app . '/'
    else
        let g:data_path = $XDG_DATA_HOME . '/' . g:app . '/'
    endif

    if empty($XDG_CACHE_HOME)
        let g:cache_path = $HOME . '/.cache/' . g:app . '/'
    else
        let g:cache_path = $XDG_CACHE_HOME . '/' . g:app . '/'
    endif
endif


if s:has_windows
    if has('nvim')
        let s:app_path = g:config_path
    else
        let s:app_path = $HOME . '/vimfiles/'
    endif
else
    if has('nvim')
        let s:app_path = g:config_path
    else
        let s:app_path = $HOME . '/.vim/'
    endif
endif

function! s:make_private_directory(path) abort
    if !isdirectory(a:path)
        call mkdir(a:path, 'p', 0700)
    endif
endfunction

function! s:make_cache_path_str(name) abort
    return g:cache_path . a:name
endfunction

function! s:make_data_path_str(name) abort
    return g:data_path . a:name
endfunction

function! s:make_cache_directory(dir_name) abort
    let l:path = s:make_cache_path_str(a:dir_name)
    call s:make_private_directory(l:path)
    return l:path
endfunction

function! s:make_data_directory(dir_name) abort
    let l:path = s:make_data_path_str(a:dir_name)
    call s:make_private_directory(l:path)
    return l:path
endfunction

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" COMMAND LINE                                                             {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set history=10000

set wildmode=full
set wildmenu
set wildcharm=<TAB>


" File Searching
" ignored files
set wildignore=*.o,*.obj,*.pyc,*.DS_Store,*.out,*.i,tags*,cscope.out
" lower priority files suffixes
set suffixes=.bak,~,.o,.info,.swp,.obj,.git,.hg,.svn

set path=
set path+=.  " To search relative to the directory of the current file
set path+=,, " To search in the current directory
set path+=** " Relative to the current directory search recursively

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" CURSOR SETTINGS                                                          {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set scrolloff=6 " Keep lines (top/bottom) for scope
set sidescrolloff=6 " Keep lines (side/side) for scope
set sidescroll=3

" In many terminal emulators the mouse works just fine, thus enable it.
if has('mouse')
    set mouse=a
endif

set ttyfast

if !has('nvim')
    set ttymouse=xterm2
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" UNDO & SWAP                                                              {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set undofile

if s:has_windows
    execute 'set undodir=' . s:make_data_directory('undo') . '\\\\'
else
    execute 'set undodir=' . s:make_data_directory('undo') . '//'
endif

set undolevels=20000
set undoreload=20000
set noswapfile

function! Undo_clean() abort
    let l:undo_files_string = globpath(&undodir, '*')
    let l:undo_files = split(l:undo_files_string, '\n')
    for l:undo_file in l:undo_files
        let l:real_file = substitute(l:undo_file, escape(&undodir, '\/\\'), '', 'g')

        if has('win32') || has('win64')
            let l:real_file = substitute(l:real_file, '%%', ':\', 'g')
            let l:real_file = substitute(l:real_file, '%', '\', 'g')
        else
            let l:real_file = substitute(l:real_file, '%', '/', 'g')
        endif

        if !filereadable(l:real_file)
            echo l:undo_file
            call delete(l:undo_file)
        endif
    endfor
endfunction


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" BACKUP                                                                   {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set backup

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" LINE WRAPPING                                                            {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set nowrap
set linebreak
set textwidth=80
if exists('+breakindent')
    set breakindent
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" SPELLING - THESAURUS - DOCS                                              {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" to work around issue in nvim run "nvim -u NORC +set\ spell"
set spell
set spelllang=en_us
let &spellfile = s:app_path . 'utils/spell/spellfile.add'
let &thesaurus = s:app_path . 'utils/thesaurus/thesaurus.txt'

execute 'helptags ' . s:app_path . 'doc'

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" TABS, INDENTING & FORMAT OPTIONS                                         {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set expandtab
set tabstop=4
set shiftwidth=4
set softtabstop=4
set smarttab

set autoindent
" these are buffer local let make them everywhere
set formatoptions+=n "recognize lists
set formatlistpat+=\\\|^\\s*[-*]\\s* "recognize lists with * or -
set formatoptions+=j "remove comments leader when joining
set formatoptions-=t "don't auto wrap based on textwidth

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" FOLDING                                                                  {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set foldcolumn=2
set foldnestmax=3
set foldlevelstart=99

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" AUTOCMDS                                                                 {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if has('autocmd')
    augroup vimrc
        autocmd!
        autocmd BufWritePost *vimrc*,init.vim nested source $MYVIMRC
    augroup END
endif

if has('autocmd')
    augroup AllFiles
        autocmd!
        autocmd FocusLost * silent! wall
    augroup END
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" SEARCHING                                                                {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set wrapscan
set incsearch
set ignorecase
set smartcase

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" TAGS                                                                     {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set tags=tags;/ "search backwards for the tags
set cscoperelative
set cscopequickfix=s-,c-,d-,i-,t-,e-

function! PrintCscopeOptions() abort
    echo 'g: Definition'
    echo 'c: Functions calling this function'
    echo 'd: Functions called by this function'
    echo 'f: This file'
    echo 'i: Files #including this file'
    echo 's: This C symbol'
    echo 't: This text string'
    echo 'e: This egrep pattern'
endfunction
execute 'nnoremap <Leader>csf :call PrintCscopeOptions()<CR>:cs find '
execute 'nnoremap <Leader>cs :call PrintCscopeOptions()<CR>:cs find   <C-r><C-w><HOME>' . repeat('<Right>',8)

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" GENERAL BEHAVIOR                                                         {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" set clipboard=unnamedplus,unnamed
set clipboard=unnamedplus
set splitright

" disable dang error{visual}bells for good
if has('autocmd')
    augroup noBells
        autocmd!
        autocmd GUIEnter * set vb t_vb=
        autocmd VimEnter * set vb t_vb=
    augroup END
endif

set nostartofline
set switchbuf=usetab
set autowriteall
set autoread
set backspace=indent,eol,start
set virtualedit+=all
set modeline

if has('nvim')
    set inccommand=nosplit
endif

set diffopt+=vertical "always open diff side by side

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" UI OPTIONS                                                               {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" set color column based on 'textwidth'
if has('autocmd')
    augroup colorcolumn
        autocmd!
        autocmd BufNewFile,BufWinEnter * let &colorcolumn = (&textwidth == 0 ? 0 : &textwidth + 1)
    augroup END
endif

set background=dark
set confirm
set shortmess+=a
set number
set relativenumber
set showcmd
set lazyredraw
set laststatus=2
set showtabline=2
set list
set listchars=trail:·,tab:→-,extends:▶,precedes:◀
set noshowmode
if v:version >= 800
    set signcolumn=yes
endif

" Maximize Window on Startup
if has ('gui_running') && has('autocmd') && s:has_windows
    augroup windowsgui:
        autocmd!
        autocmd GUIEnter * simalt ~x " maximize in windows
    augroup END
endif

" Highlight TODO, FIXME, NOTE, etc.
if has('autocmd') && v:version > 701
    augroup todo
        autocmd!
        autocmd Syntax * call matchadd(
                    \ 'Debug',
                    \ '\v\W\zs<(NOTE|INFO|IDEA|TODO|TODO_F|FIXME|CHANGED|XXX|BUG|HACK|TRICKY)>'
                    \ )
    augroup END
endif

" gui settings {{{2
if has ('gui_running')
    " Make GVim more like Terminal Vim
    set guioptions-=T "remove toolbar
    set guioptions-=r "remove right-hand scroll bar
    set guioptions-=l "remove right-hand scroll bar
    set guioptions=c "makes dialogs boxes appear like they do in console vim

    " Set Font
    try
        if s:has_windows
            set guifont=DejaVu_Sans_Mono:h9:cANSI,Lucida_Console:h9:cANSI,Consolas:h9:cANSI
        elseif has('mac')
            set guifont=DejaVu\ Sans\ Mono:h11,Monaco:h11
        elseif has('unix') && !has('mac') "linux
            set guifont=DejaVu\ Sans\ Mono\ 10
        endif
    catch
    endtry
endif "}}}2

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" MAPPINGS & COMMANDS                                                      {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set ttimeout
set ttimeoutlen=100
if has('nvim')
    set ttimeoutlen=0 " this seems to help with slow response to <Esc>
endif

set updatetime=1000

let mapleader="\<Space>"

nnoremap [myleader] <Nop>
xnoremap [myleader] <Nop>
nmap go [myleader]
xmap go [myleader]

cnoremap [cmdleader] <Nop>
cmap <C-j> [cmdleader]

if executable('ag')
    set grepprg=ag\ --vimgrep\ $*
    set grepformat=%f:%l:%c:%m
elseif executable('ack')
    set grepprg=ack\ -H\ --nocolor\ --nogroup
endif

nnoremap sal :set hlsearch<CR>:redraw<CR>:substitute///gc<Left><Left><Left>
nnoremap sG :set hlsearch<CR>:redraw<CR>:.,$substitute///gc<Left><Left><Left>
nnoremap sae :set hlsearch<CR>:redraw<CR>:%substitute///gc<Left><Left><Left>

" Navigation
" make navigation more intuitive
nnoremap <expr> k (v:count == 0 ? 'gk' : 'k')
nnoremap <expr> j (v:count == 0 ? 'gj' : 'j')
nnoremap gk k
nnoremap gj j

xnoremap <expr> k (v:count == 0 ? 'gk' : 'k')
xnoremap <expr> j (v:count == 0 ? 'gj' : 'j')
xnoremap gk k
xnoremap gj j

nnoremap <leader>f :find<Space>
nnoremap <leader>s :sfind<Space>
nnoremap <leader>v :vert sfind<Space>
nnoremap <leader>t :tabfind<Space>

nnoremap <leader>F :find <C-R>=expand('%:h') . g:path_sep<CR>
nnoremap <leader>S :sfind <C-R>=expand('%:h') . g:path_sep<CR>
nnoremap <leader>V :vert sfind <C-R>=expand('%:h') . g:path_sep<CR>
nnoremap <leader>T :tabfind <C-R>=expand('%:h') . g:path_sep<CR>

nnoremap <leader>b :buffer <TAB><S-Tab>
nnoremap <leader>B :sbuffer <TAB><S-Tab>

" replace selection with spaces and enter replace mode
xnoremap gr r<Space>gvo<Esc>R

noremap <silent><leader>rt :retab<CR>

function! CommandLineCR() abort
    let l:cmdline = getcmdline()
    command! -bar Z silent set more|delcommand Z

    if l:cmdline =~# '\v\C^(ls|files|buffers)'
        " like :ls but prompts for a buffer command
        return "\<CR>:b"

    elseif l:cmdline =~# '\v\C/(#|nu|num|numb|numbe|number)$'
        " like :g//# but prompts for a command
        return "\<CR>:"

    elseif l:cmdline =~# '\v\C^(dli|il)'
        " like :dlist or :ilist but prompts for a count for :djump or :ijump
        return "\<CR>:" . l:cmdline[0] . 'j  ' . split(l:cmdline, ' ')[1] . "\<S-Left>\<Left>"

    elseif l:cmdline =~# '\v\C^(cli|lli)'
        " like :clist or :llist but prompts for an error/location number
        return "\<CR>:sil " . repeat(l:cmdline[0], 2) . "\<Space>"

    elseif l:cmdline =~# '\C^old'
        return "\<CR>:Z|e #<"

    elseif l:cmdline =~# '\C^changes'
        " like :changes but prompts for a change to jump to
        set nomore
        return "\<CR>:Z|norm! g;\<S-Left>"

    elseif l:cmdline =~# '\C^ju'
        " like :jumps but prompts for a position to jump to
        set nomore
        return "\<CR>:Z|norm! \<C-o>\<S-Left>"

    elseif l:cmdline =~# '\C^marks'
        " like :marks but prompts for a mark to jump to
        return "\<CR>:norm! `"

    elseif l:cmdline =~# '\C^undol'
        " like :undolist but prompts for a change to undo
        return "\<CR>:u "

    else
        return "\<CR>"

    endif
endfunction

cnoremap <expr> <CR> CommandLineCR()

" underline current line with character of choice
nnoremap <silent> <leader>u :call <SID>under_line()<CR>
function! s:under_line() abort
    let l:char = escape(nr2char(getchar()), '\')
    normal! yyp
    execute ':s#\m\S.*\S\|\S#\=repeat(''' . l:char . ''',strlen(submatch(0)))#g'
endfunction

" format wile in insert mode
inoremap <C-F> <ESC>gw{zea

nnoremap <expr> <C-W><C-T> (winnr('$') != 1 ? "<C-W>TgT" : "")
nnoremap <leader>o :call PreviewWord()<CR>
nnoremap <leader>c :pclose<CR>

function! PreviewWord() abort
    if &previewwindow
        return
    endif

    let l:word_under_cursor = expand('<cword>')
    let l:is_word_under_cursor_a_letter = l:word_under_cursor =~# '\a'

    if l:is_word_under_cursor_a_letter

        " Delete any existing highlight before showing another tag
        silent! wincmd P  " jump to preview window
        if &previewwindow " if we really get there...
            match none    " delete existing highlight
            wincmd p      " back to old window
        endif

        " Try displaying a matching tag for the word under the cursor
        try
            execute ':ptag ' . l:word_under_cursor
        catch
            return
        endtry

        silent! wincmd P " jump to preview window
        if &previewwindow " if we really get there...
            if has('folding')
                silent! .foldopen  " don't want a closed fold
            endif
            call search('$', 'b')  " to end of previous line
            let l:word_under_cursor = substitute(l:word_under_cursor, '\\', '\\\\', '')
            call search('\<\V' . l:word_under_cursor . '\>')  " position cursor on match
            " Add a match highlight to the word at this position
            hi previewWord term=underline cterm=reverse gui=reverse
            execute 'match previewWord "\%' . line('.') . 'l\%' . col('.') . 'c\k*"'
            wincmd p " back to old window
        endif
    endif
endfun



" TODO add to util set
function! s:in(group, item) abort
    if type(a:group) == type('')
        let l:group = split(a:group, '\zs')
        return index(l:group, a:item) <= 0
    endif
endfunction

" think of "co" as "change option"
nnoremap comd :<C-U>set modifiable!<CR>:set modifiable?<CR>
nnoremap coro :<C-U>set readonly!<CR>:set readonly?<CR>
nnoremap cot :<C-U>set textwidth=
nnoremap cocl :<C-U>setlocal conceallevel=
nnoremap cosw :<C-U>set shiftwidth=
nnoremap <silent> conf :<C-U>call <SID>scratch_toggle()<CR>
function! s:scratch_toggle() abort
    if match(&buftype, '\C\v'.'nofile') != -1
        set buftype-=nofile
    else
        set buftype+=nofile
    endif
endfunction
function! s:format_options_toggle(options, message) abort
    let l:options = split(a:options, '\zs')

    for l:option in l:options
        if s:in(&formatoptions, l:option)
            let l:add_or_subtract = '+='
            let l:message = printf('on: %s', a:message)
        else
            let l:add_or_subtract = '-='
            let l:message =  printf('off: %s', a:message)
        endif
        execute 'set formatoptions' . l:add_or_subtract . l:option
    endfor
    set formatoptions?
    echo l:message
endfunction
nnoremap cotw :<C-U>call <SID>format_options_toggle('t', 'auto wrap using textwidth')<CR>
nnoremap copw :<C-U>call <SID>format_options_toggle('aw' 'auto formmating of paragraphs')<CR>

" reselect pasted or last changed text
nnoremap <expr> g<C-v> '`[' . getregtype()[0] . '`]'

nnoremap <C-w>Q :tabclose<CR>


" redraw even harder
nnoremap <silent><C-l> :redraw!<CR><C-l>

" open my vimrc
nnoremap [myleader]rc :e $MYVIMRC<CR>

nnoremap <C-W>d :bd<CR>

" make more undos possible after leaving insert mode
inoremap <C-u> <C-g>u<C-u>
inoremap <C-w> <C-g>u<C-w>
inoremap <BS> <C-g>u<BS>
inoremap <Del> <C-g>u<Del>
inoremap <End> <C-g>u<End>
inoremap <Space> <C-g>u<Space>

" yank to end of line, kinda like D or C
noremap Y y$

" visual selection text object
xnoremap a/ gn
onoremap a/ gn
xnoremap i/ gn
onoremap i/ gn
xnoremap i? gN
onoremap i? gN
xnoremap a? gN
onoremap a? gN

" disable Ex mode key and use it to repeat the last q macro (love this)
nnoremap Q @q
" replay q macro for each line of a visual selection
xnoremap Q :normal! @q<CR>
" repeat last command for each line of a visual selection
xnoremap . :normal! .<CR>
" repeat last command then go to the next search position
nnoremap <C-n> n.
" repeat last command-line command
nnoremap g. @:

" set path to present working directory locally
nnoremap cdl :lcd! %:h<CR>:pwd<CR>
nnoremap cd :cd! %:h<CR>:pwd<CR>

nnoremap <leader>qa :qa!<CR>
nnoremap <leader>q :q!<CR>

" navigation in command line
cnoremap <C-p> <UP>
cnoremap <C-n> <DOWN>
cnoremap <C-b> <LEFT>
cnoremap <C-f> <RIGHT>
cnoremap <C-a> <HOME>
cnoremap <C-e> <END>
cnoremap <C-x> <C-]>
cnoremap <C-s> <C-f>

" find files easier
cnoremap <C-t> <C-r>=expand('%:p:h') . '/'<CR>

" afp File Path  (/something/src/foo.txt)
" fp File Path relative  (src/foo.txt)
" ofn Other File Name (trail)
" aofp Other File Path
" ofp Other File Path Relative to pwd
" adp Directory Path (head) (/something/src)
" dp Directory Path Relative to pwd (head) (/something/src)
" pwd Present Working Directory
let s:extension_patter = '\(\(.\{1,}\.\)\w\+$\)\?'
let s:maps = [
            \     {
            \         'str': 'fn',
            \         'func': "expand('%:t')"
            \     },
            \     {
            \         'str': 'afp',
            \         'func': "expand('%:p')"
            \     },
            \     {
            \         'str': 'fp',
            \         'func': "expand('%')"
            \     },
            \     {
            \         'str': 'ofn',
            \         'func': "substitute(expand('%:t'), '"
            \         . s:extension_patter . "', '\\2', 'g')"
            \     },
            \     {
            \         'str': 'aofp',
            \         'func': "substitute(expand('%:p:r:.'), '"
            \         . s:extension_patter . "', '\\2', 'g')"
            \     },
            \     {
            \         'str': 'ofp',
            \         'func': "expand('%<') . '.'"
            \     },
            \     {
            \         'str': 'adp',
            \         'func': "expand('%:p:h') . '/'"
            \     },
            \     {
            \         'str': 'dp',
            \         'func': "expand('%:h') . '/'"
            \     },
            \     {
            \         'str': 'pwd',
            \         'func': 'getcwd()'
            \     }
            \  ]
for s:map in s:maps
    execute 'nnoremap <silent> <Leader>y' . s:map.str . ' ' .
                \ ':let @*=' . s:map.func . '<CR>' .
                \ ':let @+=' . s:map.func . '<CR>' .
                \ ':let @"=' . s:map.func . '<CR>'
    execute 'cnoremap %' . s:map.str . ' <C-r>=' . s:map.func . '<CR>'
endfor

" accept completion (requires "set wildcharm = <TAB>)
cnoremap <C-y> <SPACE><BS><TAB>

cnoremap %date <C-r>=strftime('%Y-%m-%d')<CR>

let $zsh = '~/.zshrc'
let $zshl = '~/.zshrc_local'
let $shf = '~/.config/shell/functions.sh'
let $git = '~/.gitconfig'
let $gitl = '~/.gitconfig_local'
let $vim = '$MYVIMRC'
let $viml = '~/.vimrc_local'
let $tmux = '~/.tmux.conf'
let $t = '~/Dropbox/notes/todo.txt'
let $i = '~/Dropbox/notes/inbox.md'
let $j = '~/Dropbox/notes/journal.md'

cnoremap ~f ~/Dropbox
cnoremap ~p ~/Dropbox/projects
cnoremap ~n ~/Dropbox/notes
cnoremap ~df ~/dotfiles
cnoremap ~dfl ~/dotfiles_local

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" SCRIPTS                                                                  {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
nnoremap <leader>m  :call SearchPosition()<CR>
nnoremap <leader>M  :let @/ = ''<CR>
function! SearchPosition() abort
    if @/ !~# '\v(\\\%\d+[lc](\\\|)?)+'
        let @/ = ''
        " echo "pattern didn't match = ".@/
    else
        let @/ .= '\|'
        " echo "added bar = ".@/
    endif

    let l:line = getpos('.')[1]
    let l:col = getpos('.')[2]
    execute "let @/ .= '\\%" . l:line . "l'"
    execute "let @/ .= '\\%" . l:col . "c'"
endfunction

nnoremap g** :<C-U>call AddToSearch('n')<CR>
xnoremap g* :<C-U>call AddToSearch('x')<CR>
function! AddToSearch(mode) abort
    let l:save_reg = @@
    if @/ !=# ''
        let @/ .= '\|'
    endif
    if a:mode ==# 'x'
        normal! gvy
    elseif a:mode ==# 'n'
        normal! yiw
    else
        let @@ = l:save_reg
    endif
    let @/ .= @@
    let @@ = l:save_reg
endfunction

nnoremap <Leader>tp :ptjump <C-r><C-w><CR>

" reverse selection kind of works
vnoremap <silent> <leader>is :<c-u>let old_reg_a=@a<cr>
            \:let old_reg=@"<cr>
            \gv"ay
            \:let @a=substitute(@a, '.\(.*\)\@=',
            \ '\=@a[strlen(submatch(1))]', 'g')<CR>
            \gvc<C-R>a<Esc>
            \:let @a=old_reg_a<CR>
            \:let @"=old_reg<CR>


command! -nargs=* -range=0 -bang Seq
            \ call Seq(<count>, <line1>, <line2>, <q-args>, "<bang>")

function! Seq(count, first_line, last_line, cmdInput, bang) abort
    " anything within backticks
    let l:rg_expr = '`\(.\{-1,}\)`'

    " 1 index if ! is used
    if a:bang !=# '!'
        let x = 0
    else
        let x = 1
    endif

    let @a = ''
    let r = ''
    for i in range(0, a:last_line-a:first_line) "TODO fails without a range
        let l:line = substitute(a:cmdInput, l:rg_expr, '\=eval(submatch(1))', 'g')
        echomsg l:line
        " call append(i+a:first_line, line)
        let r = r.l:line."\n"
        echomsg r
        let x = x + 1
    endfor
    call setreg('a', r,  'b')
    normal! "aP
endfunction

command! -nargs=* -range=0 -bang Renumber
            \ call <SID>renumber(<line1>, <line2>, "<bang>")
function! s:renumber(first_line, last_line, bang) abort
    let num_expr = '\v\C^.{-}\zs\d+\ze'
    " 0 index if ! is used
    if a:bang !=# '!'
        let s:renumber_index = 1
    else
        let s:renumber_index = 0
    endif

    execute a:first_line.','.a:last_line.'s#'.num_expr.'#\=s:increment()#'
endfunction

function! s:increment() abort
    let old_renumber_index = s:renumber_index
    let s:renumber_index = s:renumber_index + 1
    return old_renumber_index
endfunction

" add numbers to the front or end of a line
cabbrev numend s/$/\=1-line("'<")+line(".")/c
cabbrev numfront s/^/\=1-line("'<")+line(".")/c

function! Git_status() abort
    let output = system('git status --porcelain')
    let escaped = escape(output, ' ')
    let subbed_start = substitute(escaped, '^...\', '', 'g')
    let subbed = substitute(subbed_start, '\n...', ' ', 'g')
    execute 'args ' . subbed
endfunction


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" BEFORE PLUGINS                                                           {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if filereadable(glob('.vimrc_project'))
    source .vimrc_project
endif

if filereadable(glob('~/.vimrc_local', 1))
    source ~/.vimrc_local
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" PLUGINS                                                                  {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let g:ale_emit_conflict_warnings = 0  " has to be run before loading plugins

let g:dein#types#git#clone_depth = 1
let s:plugin_path = s:make_cache_directory('plugins')
let s:dein_path = s:plugin_path . '/dein'
if !isdirectory(s:dein_path)
    execute '!git clone https://github.com/Shougo/dein.vim ' . s:dein_path
endif

if has('vim_starting')
    execute 'set runtimepath+=' . s:dein_path .  '/'
endif

let s:dein_path_plugins = s:plugin_path . '/bundle'

if dein#load_state(s:dein_path_plugins)
    call dein#begin(s:dein_path_plugins)

    call dein#add(s:dein_path)
    call dein#add('Shougo/vimproc.vim', {'build': 'make'})

    " text objects {{{2
    call dein#add('kana/vim-textobj-user')
    call dein#add('saihoooooooo/vim-textobj-space')
    call dein#add('Julian/vim-textobj-variable-segment')
    call dein#add('kana/vim-textobj-entire')
    call dein#add('kana/vim-textobj-indent')
    call dein#add('kana/vim-textobj-line')
    call dein#add('kana/vim-textobj-syntax')
    call dein#add('mattn/vim-textobj-url')
    call dein#add('glts/vim-textobj-comment')
    call dein#add('thinca/vim-textobj-between')
    call dein#add('osyo-manga/vim-textobj-multiblock')
    " call dein#add('kana/vim-textobj-function')
    call dein#add('sgur/vim-textobj-parameter')
    call dein#add('osyo-manga/vim-textobj-blockwise')
    "}}}2

    " {u,de}nite {{{2
    call dein#add('Shougo/denite.nvim')
    call dein#add('Shougo/neoyank.vim', {'depends' : 'Shougo/denite.nvim'})
    call dein#add('Shougo/neomru.vim', {'depends' : 'Shougo/denite.nvim'})
    call dein#add('naquad/unite-digraphs', {'depends' : 'Shougo/denite.nvim'})
    call dein#add('Shougo/unite.vim')
    " }}}2

    call dein#add('dyng/ctrlsf.vim')

    " Operators
    call dein#add('kana/vim-operator-user')
    call dein#add('arecarn/vim-operator-mixed-case')
    call dein#add('kana/vim-operator-replace' , {'depends' : 'kana/vim-operator-user'})
    call dein#add('tpope/vim-surround')
    call dein#add('tommcdo/vim-exchange')
    call dein#add('tpope/vim-commentary')
    call dein#add('tpope/vim-repeat')
    call dein#add('vim-scripts/visualrepeat')
    "}}}2

    " Folds
    call dein#add('arecarn/vim-clean-fold')
    call dein#add('arecarn/vim-fold-cycle') "  {'rev' : 'topics/global_fold_cycling'})


    " Visual Enhancements
    call dein#add('itchyny/lightline.vim')
    call dein#add('chreekat/vim-paren-crosshairs')
    call dein#add('junegunn/goyo.vim')
    call dein#add('nathanaelkane/vim-indent-guides')

    if !s:has_windows
        call dein#add('edkolev/tmuxline.vim')
    endif

    call dein#add('w0rp/ale')
    call dein#add('tpope/vim-dispatch')
    call dein#add('janko-m/vim-test')


    " Vim script Development
    call dein#add('vim-jp/vital.vim')
    call dein#add('tpope/vim-scriptease')
    call dein#add('junegunn/vader.vim')
    call dein#add('vim-scripts/Decho')
    call dein#add('dbakker/vim-lint', {'depends' : 'scrooloose/syntastic'})


    " File Type
    call dein#add('stephpy/vim-yaml') "and alternative YAML sine the built in one is slow
    call dein#add('lopter/moin.vim')
    call dein#add('vim-scripts/confluencewiki.vim')
    call dein#add('plasticboy/vim-markdown')
    call dein#add('dbeniamine/todo.txt-vim')
    call dein#add('vim-scripts/scons.vim')
    call dein#add('romainl/vim-qf')

    call dein#add('hynek/vim-python-pep8-indent')
    call dein#add('python-rope/ropevim')

    " Colors
    call dein#add('morhetz/gruvbox')


    " Completion
    call dein#add('roxma/nvim-completion-manager',
                \ {'depends' : 'roxma/vim-hug-neovim-rpc'})

    call dein#add('roxma/vim-hug-neovim-rpc')
    call dein#add('roxma/nvim-yarp')

    call dein#add('tom95/deoplete-clang2', {'depends' : 'Shougo/deoplete.nvim'})

    call dein#add('zchee/deoplete-jedi', {'depends' : 'Shougo/deoplete.nvim'})
    call dein#add('Shougo/neco-vim', {'depends' : 'Shougo/deoplete.nvim'})
    call dein#add('zchee/deoplete-zsh', {'depends' : 'Shougo/deoplete.nvim'})

    if !s:has_windows
        call dein#add('wellle/tmux-complete.vim', {'depends' : 'Shougo/deoplete.nvim'})
    endif
    call dein#add('Shougo/neoinclude.vim', {'depends' : 'Shougo/deoplete.nvim'})
    call dein#add('Shougo/echodoc.vim')


    call dein#add('Shougo/neosnippet-snippets')
    call dein#add('Shougo/neosnippet.vim')


    " Git / VCS
    call dein#add('tpope/vim-fugitive')
    call dein#add('jreybert/vimagit')
    call dein#add('airblade/vim-rooter')
    call dein#add('cohama/agit.vim')
    call dein#add('mhinz/vim-signify')


    " Diff
    call dein#add('AndrewRadev/linediff.vim')
    call dein#add('vim-scripts/diffchanges.vim')
    call dein#add('arecarn/vim-diff-utils')
    call dein#add('chrisbra/vim-diff-enhanced')
    call dein#add('will133/vim-dirdiff')


    " Applications
    call dein#add('Shougo/vimfiler.vim', {'depends' : 'Shougo/unite.vim'})
    call dein#add('idanarye/vim-vebugger', {'depends' : 'Shougo/vimproc.vim'})
    call dein#add('metakirby5/codi.vim')
    call dein#add('vimwiki/vimwiki')


    " Text Manipulation Commands / Mappings
    call dein#add('junegunn/vim-easy-align')
    call dein#add('godlygeek/tabular')
    call dein#add('arecarn/vim-split-join')
    call dein#add('t9md/vim-textmanip')
    call dein#add('vim-scripts/ingo-library')
    call dein#add('vim-scripts/FormatToWidth', {'depends' : 'vim-scripts/ingo-library'})

    " Enhancements
    call dein#add('kana/vim-niceblock')
    call dein#add('tpope/vim-speeddating')
    call dein#add('tpope/vim-unimpaired')
    call dein#add('vim-scripts/UnconditionalPaste')
    call dein#add('arecarn/vim-go-to-buffer')
    call dein#add('arecarn/vim-auto-autoread')
    call dein#add('arecarn/vim-backup-tree')
    call dein#add('thinca/vim-qfreplace')
    call dein#add('tpope/vim-eunuch')
    call dein#add('arecarn/vim-spell-utils')
    call dein#add('tpope/vim-abolish')

    " Word Under the Cursor Highlighting
    call dein#add('t9md/vim-quickhl')
    call dein#add('qstrahl/vim-matchmaker')

    " Search
    call dein#add('junegunn/vim-slash')
    call dein#add('mhinz/vim-grepper')

    " Utilities
    call dein#add('talek/obvious-resize')
    call dein#add('vim-scripts/cmdalias.vim')
    call dein#add('arecarn/Preserve.vim') "TODO Merge into the true one

    " Interactive Tools/Modes
    call dein#add('dhruvasagar/vim-table-mode')
    call dein#add('vim-scripts/DrawIt')
    call dein#add('arecarn/vim-selection')
    call dein#add('arecarn/vim-crunch', {'depends' : 'arecarn/vim-selection'})
    call dein#add('chrisbra/NrrwRgn')
    call dein#add('mbbill/undotree')

    call dein#add('arecarn/vim-binascii')
    call dein#add('arecarn/vim-frisk')
    call dein#add('arecarn/vim-template', {'rtp': ''})

    " Project Management
    call dein#add('ludovicchabant/vim-gutentags')
    call dein#add('tpope/vim-projectionist')

    call dein#end()
    call dein#save_state()
endif

if dein#check_install()
    call dein#install()
    call dein#remote_plugins()
endif

command! DeinInstall if dein#check_install() | call dein#install() | endif
command! DeinUpdate call dein#update()

filetype plugin indent on
syntax on
if !exists("g:syntax_on")
    syntax enable
endif
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" PLUGINS CONFIG                                                           {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if dein#tap('vim-backup-tree') "{{{2
    let g:backup_tree = s:make_data_directory('backup')
endif "}}}2


if dein#tap('echodoc.vim') "{{{2
    let g:echodoc#enable_at_startup = 1
    if &showmode
        set cmdheight=2
    endif
    set completeopt-=preview
    set shortmess+=c
endif "}}}2

if dein#tap('deoplete.nvim') "{{{2
    let g:deoplete#enable_at_startup = 1
    let g:deoplete#sources#clang#sort_algo = 'priority'
endif "}}}2

if dein#tap('neosnippet-snippets') "{{{2
    imap <C-e> <Plug>(neosnippet_expand_or_jump)
    smap <C-e> <Plug>(neosnippet_expand_or_jump)
    xmap <C-e> <Plug>(neosnippet_expand_target)

    if has('conceal')
        set conceallevel=2 concealcursor=i
    endif

    let g:neosnippet#snippets_directory = s:app_path . 'utils/snippets'
    let g:neosnippet#data_directory = s:make_cache_path_str('neosnippet')
endif "}}}2

if dein#tap('unite.vim') "{{{2
    let g:unite_data_directory = s:make_cache_path_str('unite')
    let g:unite_winheight = 10
    let g:unite_split_rule = 'botright'
    call unite#filters#sorter_default#use(['sorter_rank'])
endif "}}}2

if dein#tap('denite.nvim') "{{{2
    if dein#tap('unite-digraphs')
        command! Digraphs Denite unite:digraphs
    endif

    if dein#tap('neoyank.vim')
        nnoremap [myleader]p  :<C-u>Denite -mode=normal neoyank<CR>
        xnoremap [myleader]p  dk:<C-u>Denit -mode=normale neoyank<CR>

        let g:neoyank#file = s:make_data_path_str('neoyank/history')
    endif

    if dein#tap('neomru.vim')
        nnoremap [myleader]r :<C-u>Denite file_mru<CR>

        let g:neomru#file_mru_path = s:make_cache_path_str('neomru/file')
        let g:neomru#directory_mru_path = s:make_cache_path_str('neomru/directory')
    endif

    nnoremap [myleader]d :<C-u>Denite directory_rec<CR>
    nnoremap [myleader]f :<C-u>Denite file_rec<CR>
    nnoremap [myleader]rg :<C-u>Denite -mode=normal register<CR>
    nnoremap [myleader]b  :<C-u>Denite buffer<CR>
    nnoremap [myleader]l  :<C-u>Denite line<CR>
    nnoremap [myleader]t  :<C-u>Denite tag<CR>
    nnoremap [myleader]:  :<C-u>Denite<Space><C-d>
    cnoremap <silent> <C-r><C-r> <C-u>Denite command_history<CR>
    cnoremap <silent> <C-o> <C-u>Denite command<CR>

    command! Messages Denite -mode=normal output:message

endif "}}}2

if dein#tap('vimfiler.vim') "{{{2
    " Replace entry commands with Vimfiler
    let g:loaded_netrw = 1
    let g:loaded_netrwPlugin = 1
    let g:vimfiler_as_default_explorer = 1
    let g:vimfiler_data_directory = s:make_cache_path_str('vimfiler')

    command! -nargs=* Explore :VimFilerBufferDir <Args>
    command! -nargs=* Sexplore :VimFilerBufferDir -split -horizontal <Args>
    command! -nargs=* Vexplore :VimFilerBufferDir -split  <Args>
    command! -nargs=* Texplore :VimFilerBufferDir -tab <Args>
else
    " setup netrw
    " set up line numbering and other good stuff
    let g:netrw_bufsettings = 'noma nomod rnu nobl nowrap ro'

endif "}}}2

if dein#tap('vim-grepper') "{{{2
    nmap [myleader]g: :Grepper<CR>
    nmap [myleader]g <plug>(GrepperOperator)
    xmap [myleader]g <plug>(GrepperOperator)
endif "}}}2

if dein#tap('vim-dispatch') "{{{2
    nnoremap [myleader]m :Make<CR>
    nnoremap [myleader]m: :Make<Space>
endif "}}}2

if dein#tap('vim-fugitive') "{{{2
    command! -nargs=* G :Git <Args>
    nnoremap <Leader>gs :Gstatus<CR>
    nnoremap <Leader>gd :Gdiff<CR>
    nmap <Leader>gc :Gstatus<CR>cc<C-w>T:vs<CR>/>8<CR>z<CR><C-w>p
    nmap ]gd :Gstatus<CR><C-w>K<C-n>D
    nmap [gd :Gstatus<CR><C-w>K<C-p>D
    nmap ]g :Gstatus<CR><C-w>K<C-n><CR>
    nmap [g :Gstatus<CR><C-w>K<C-p><CR>

    " Jump to last known cursor position on BufReadPost {{{
    " Don't do it when the position is invalid or when inside an event handler
    " (happens when dropping a file on gvim).
    " NOTE: read viminfo/marks, but removed: causes issues with jumplist sync
    " across Vim instances
    " \   rviminfo |
    " NOTE: removed for SVN commit messages: && fnamemodify(bufname('%'), ':t') != 'svn-commit.tmp'
    " ref: :h last-position-jump
    fun! AutojumpLastPosition()
        if ! exists('b:autojumped_init')
            let b:autojumped_init = 1
            if &ft !=# 'gitcommit' && &ft !=# 'diff' && ! &diff && line("'\"") <=# line('$') && line("'\"") > 0
                " NOTE: `zv` is ignored with foldlevel in modeline.
                exe 'normal! g`"zv'
            endif
        endif
    endfun

    " Follow symlinks when opening a file {{{
    " NOTE: this happens with directory symlinks anyway (due to Vim's chdir/getcwd
    "       magic when getting filenames).
    " Sources:
    "  - https://github.com/tpope/vim-fugitive/issues/147#issuecomment-7572351
    "  - http://www.reddit.com/r/vim/comments/yhsn6/is_it_possible_to_work_around_the_symlink_bug/c5w91qw
    function! MyFollowSymlink(...) abort
        if exists('w:no_resolve_symlink') && w:no_resolve_symlink
            return
        endif
        if &ft ==# 'help'
            return
        endif
        let fname = a:0 ? a:1 : expand('%')
        if fname =~# '^\w\+:/'
            " Do not mess with 'fugitive://' etc.
            return
        endif
        let fname = simplify(fname)

        let resolvedfile = resolve(fname)
        if resolvedfile == fname
            return
        endif
        let resolvedfile = fnameescape(resolvedfile)
        let sshm = &shm
        set shortmess+=A  " silence ATTENTION message about swap file (would get displayed twice)
        redraw  " Redraw now, to avoid hit-enter prompt.
        exec 'file ' . resolvedfile
        let &shm=sshm

        call AutojumpLastPosition()
        unlet! b:git_dir
        call fugitive#detect(resolvedfile)

        if &modifiable
            " Only display a note when editing a file, especially not for `:help`.
            redraw  " Redraw now, to avoid hit-enter prompt.
            echomsg 'Resolved symlink: =>' resolvedfile
        endif
    endfunction
    command! -bar FollowSymlink call MyFollowSymlink()
endif "}}}2

if dein#tap('vim-split-join') "{{{2
    command! -range -bang SplitS <line1>,<line2>Split<bang>/[^[:space:]]\zs\s\+/
endif "}}}2

if dein#tap('tabular') "{{{2
    nnoremap <Leader>a :Tabularize/
    xnoremap <Leader>a :Tabularize/
endif "}}}2

if dein#tap('vim-table-mode') "{{{2
    let g:table_mode_corner = '|'
endif "}}}2

if dein#tap('vim-indent-guides') "{{{2
    nmap <silent> coig <Plug>IndentGuidesToggle
    let g:indent_guides_enable_on_vim_startup = 0
    let g:indent_guides_default_mapping = 0
    let g:indent_guides_guide_size = 1
    let g:indent_guides_start_level = 2
endif "}}}2

if dein#tap('syntastic') "{{{2
    let g:syntastic_check_on_open = 0
    " let g:syntastic_python_checkers = ['python', 'pylint']
    let g:syntastic_python_checkers = ['python']
    nnoremap cost :SyntasticToggleMode<CR>
endif "}}}2

if dein#tap('vim-textmanip') "{{{2
    xmap <C-j> <Plug>(textmanip-move-down)
    xmap <C-k> <Plug>(textmanip-move-up)
    xmap <C-h> <Plug>(textmanip-move-left)
    xmap <C-l> <Plug>(textmanip-move-right)

    xmap g<C-j> <Plug>(textmanip-duplicate-down)
    xmap g<C-k> <Plug>(textmanip-duplicate-up)
    xmap g<C-h> <Plug>(textmanip-duplicate-left)
    xmap g<C-l> <Plug>(textmanip-duplicate-right)

    xmap gb<C-j> <Plug>(textmanip-blank-below)
    xmap gb<C-k> <Plug>(textmanip-blank-above)

    " toggle insert/replace with
    nmap cotm <Plug>(textmanip-toggle-mode)
endif "}}}2

if dein#tap('vim-quickhl') "{{{2
    nmap gm <Plug>(quickhl-manual-this)
    xmap gm <Plug>(quickhl-manual-this)
    nmap gmx <Plug>(quickhl-manual-reset)
    xmap gmx <Plug>(quickhl-manual-reset)
endif "}}}2

if dein#tap('cmdalias.vim') "{{{2
    command! Pwf echo expand('%:p')
    augroup VIMRC_aliases
        autocmd!
        autocmd VimEnter * Alias pwf Pwf
        autocmd VimEnter * Alias ex Explore
        autocmd VimEnter * Alias sex Sexplore
        autocmd VimEnter * Alias tex Texplore
        autocmd VimEnter * Alias vex Vexplore
    augroup END
endif "}}}2

if dein#tap('FormatToWidth') "{{{2
    xmap gQ <Plug>FormatToWidth
endif "}}}2

if dein#tap('linediff.vim') "{{{2
    xnoremap <Leader>ld :Linediff<CR>
endif "}}}2

if dein#tap('vim-textobj-between') "{{{2
    let g:textobj_between_no_default_key_mappings = 1
    xmap am <Plug>(textobj-between-a)
    omap am <Plug>(textobj-between-a)
    xmap im <Plug>(textobj-between-i)
    omap im <Plug>(textobj-between-i)
endif "}}}2

if dein#tap('vim-markdown') "{{{2
    let g:vim_markdown_conceal = 0
endif "}}}2

if dein#tap('vim-table-mode') "{{{2
    let g:table_mode_separator = '|'
endif "}}}2

if dein#tap('undotree') "{{{2
    nnoremap [myleader]ut :UndotreeToggle<CR>:UndotreeFocus<CR>
endif "}}}2

if dein#tap('goyo.vim') "{{{2
    nnoremap cof :<C-u>call SetGoyo(v:count)<CR>

    function! s:goyo_enter() abort
        let b:wrap_cache = &wrap
        let b:list_cache = &list
        let &wrap = 1
        let &list = 0
    endfunction

    function! s:goyo_leave() abort
        let &wrap = b:wrap_cache
        let &list = b:list_cache
    endfunction

    augroup augroup_name
        autocmd!
        autocmd User GoyoEnter nested call <SID>goyo_enter()
        autocmd User GoyoLeave nested call <SID>goyo_leave()
    augroup END
    function! SetGoyo(num) abort
        if a:num == 0
            Goyo
        else
            execute 'Goyo ' . string(a:num)
        endif


    endfunction
endif "}}}2

if dein#tap('scons.vim') "{{{2
    augroup SCONS
        autocmd!
        autocmd BufNewFile,BufRead SCons*,scons* set filetype=scons
    augroup END
endif "}}}2

if dein#tap('todo.txt-vim') "{{{2
    augroup TODO_TXT
        autocmd!
        autocmd BufNewFile,BufRead *todo.txt,*done.txt set filetype=todo
        autocmd BufNewFile,BufRead todo*.txt,done*.txt set filetype=todo
        autocmd FileType todo call s:todo_txt_settings()
        autocmd FileType todo setlocal formatoptions-=t
    augroup END

    function! s:get_context(line) abort "{{{3
        return matchstr(getline(a:line), '@[^ ]\+')
    endfunction "}}}3

    function! s:get_project(line) abort "{{{3
        return matchstr(getline(a:line), '+[^ ]\+')
    endfunction "}}}3

    function! Todo_fold_text(foldchar) abort "{{{3
        let line = s:get_context(v:foldstart)
        let lines_count = v:foldend - v:foldstart + 1
        let lines_count_text = '| ' . printf('%10s', lines_count . ' todos') . ' |'
        let foldtextstart = strpart(line, 0, (winwidth(0)*2)/3)
        let foldtextend = lines_count_text . repeat(a:foldchar, 8)
        let foldtextlength = strlen(substitute(foldtextstart . foldtextend, '.', 'x', 'g')) + &foldcolumn
        return foldtextstart . repeat(a:foldchar, winwidth(0)-foldtextlength) . foldtextend
    endfunction "}}}3

    function! Todo_fold(lnum) abort "{{{3
        let this_context = s:get_context(a:lnum)
        let next_context = s:get_context(a:lnum - 1)

        let fold_level = '0'

        if this_context ==# next_context
            let fold_level = '1'
        else
            let fold_level = '>1'
        endif

        return fold_level
    endfunction "}}}3

    nnoremap <localleader>w :s/\s*@[a-z-]\+\s*$\\|\s*$/ @work/<CR>
    xnoremap <localleader>w :s/\s*@[a-z-]\+\s*$\\|\s*$/ @work/<CR>
    nnoremap <localleader>h :s/\s*@[a-z-]\+\s*$\\|\s*$/ @home/<CR>
    xnoremap <localleader>h :s/\s*@[a-z-]\+\s*$\\|\s*$/ @home/<CR>

    function! s:todo_txt_settings() abort "{{{3
        try
            execute "iunmap <buffer> date\<TAB>"
            iunmap <buffer> due:
        catch
        endtry

        " update time
        " TODO fix issue where search pattern leaks into search history
        nnoremap <localleader>ud :s/\d\d\d\d-\d\d\-\d\d/\=strftime("%Y-%m-%d")/<CR>

        setlocal foldmethod=expr
        setlocal foldexpr=Todo_fold(v:lnum)
        setlocal foldtext=Todo_fold_text('_')
        setlocal iskeyword+=+,_,.
        setlocal iskeyword+=@-@ " add literal @

        if dein#tap('neocomplete') "{{{3
            " use iskeyword characters in neocompletion
            let keyword_patterns = {}
            let keyword_patterns.todo = '\k\+'
            call neocomplete#custom#source('buffer',
                        \ 'keyword_patterns', keyword_patterns)
        endif
    endfunction "}}}3
endif "}}}2

if dein#tap('obvious-resize') "{{{2
    " map F9 - F12 (like hjkl) to resize windows
    nnoremap <silent><Left> :ObviousResizeLeft<CR>
    nnoremap <silent><Down> :ObviousResizeDown<CR>
    nnoremap <silent><Up> :ObviousResizeUp<CR>
    nnoremap <silent><Right> :ObviousResizeRight<CR>
endif "}}}2

if dein#tap('Preserve.vim') "{{{2
    command! -range=% Dlead :PreserveSave|<line1>,<line2>s,^\s\+,,ge|PreserveRestore
    noremap <silent><leader>dl :Dlead<CR>
    command! -range=% Dtrail :PreserveSave|<line1>,<line2>s,\s\+$,,ge|PreserveRestore
    noremap <silent><leader>dt :Dtrail<CR>
    nnoremap =ae :call Preserve("normal! gg=G")<CR>
    nnoremap =ie :call Preserve("normal! gg=G")<CR>
    nnoremap yae :call Preserve("normal! ggyG")<CR>
    nnoremap yie :call Preserve("normal! ggyG")<CR>
endif "}}}2

if dein#tap('moin.vim') "{{{2
    augroup MOIN
        autocmd!
        autocmd BufNewFile,BufRead *.moin set filetype=moin
    augroup END
endif "}}}2

if dein#tap('confluencewiki.vim') "{{{2
    augroup MOIN
        autocmd!
        autocmd BufNewFile,BufRead *.jira set filetype=confluencewiki
    augroup END
endif "}}}2

if dein#tap('vim-crunch') "{{{2
    let g:crunch_user_variables = {'e': exp(1),  'pi':3.14159265359}
    let g:crunch_result_type_append = 2
endif "}}}2

if dein#tap('vim-surround') "{{{2
    " custom surround using :
    let g:surround_58 = "\1Surround\1\r\1\1"
endif "}}}2

if dein#tap('vim-clean-fold') "{{{2
    set foldmethod=expr
    set foldtext=clean_fold#fold_text_minimal()
    set foldexpr=clean_fold#fold_expr(v:lnum)
else
    set foldmethod=indent
endif "}}}2

if dein#tap('vim-matchmaker') "{{{2
    let g:matchmaker_enable_startup = 1

    " change option highlight word
    nnoremap cohw :MatchmakerToggle<CR>

    augroup matchmaker
        autocmd!
        autocmd ColorScheme * highlight Matchmaker term=underline ctermbg=238 guibg=#444444
    augroup END
endif "}}}2

if dein#tap('vim-rooter') "{{{2
    let g:rooter_manual_only = 1
    let g:rooter_disable_map = 1
    let g:rooter_use_lcd = 0
    map <silent> cdp <Plug>RooterChangeToRootDirectory
endif "}}}2

if dein#tap('vim-fold-cycle') "{{{2
    let g:fold_cycle_default_mapping = 0
    nmap zo <Plug>(fold-cycle-open)
    nmap zc <Plug>(fold-cycle-close)
    nmap zO <Plug>(fold-cycle-open-all)
    nmap zC <Plug>(fold-cycle-close-all)
    nmap zA <Plug>(fold-cycle-toggle-all)
    " nmap zr <Plug>(fold-cycle-open-global)
    " nmap zm <Plug>(fold-cycle-close-global)
endif "}}}2

if dein#tap('vim-operator-replace') "{{{2
    map _ <Plug>(operator-replace)
endif "}}}2

if dein#tap('gruvbox') "{{{2
    let g:gruvbox_guisp_fallback = 'fg'
    colorscheme gruvbox
endif "}}}2

if dein#tap('lightline.vim') "{{{2
    let g:lightline = {
                \ 'colorscheme': 'gruvbox',
                \ 'active': {
                \     'left': [['winnr', 'bufnr', 'mode', 'paste'], ['fugitive', 'filename']]
                \ },
                \ 'inactive' : {
                \     'left': [['winnr', 'bufnr', 'filename']],
                \ },
                \ 'component_function': {
                \     'modified': 'Lightline_modified',
                \     'readonly': 'Lightline_readonly',
                \     'fugitive': 'Lightline_fugitive',
                \     'filename': 'Lightline_filename',
                \     'fileformat': 'Lightline_fileformat',
                \     'filetype': 'Lightline_filetype',
                \     'fileencoding': 'Lightline_fileencoding',
                \     'mode': 'Lightline_mode',
                \     'winnr': 'Lightline_winnr',
                \     'bufnr': 'Lightline_bufnr',
                \ }}

    function! Lightline_modified() abort
        return &ft =~# 'help\|vimfiler' ? '' : &modified ? '+' : &modifiable ? '' : '-'
    endfunction

    function! Lightline_readonly() abort
        return &ft !~? 'help\|vimfiler' && &readonly ? 'RO' : ''
    endfunction

    function! Lightline_filename() abort
        let file_name = bufname('%')

        if file_name == ''
            let file_name = '[No Name]'
        else
            if winwidth(0) - len(file_name) < 40
                let file_name = substitute(file_name, '\v([^/\\:])[^/\\:]*([/\\])', '\1\2', 'g' )
            endif
        endif

        return ('' !=# Lightline_readonly() ? Lightline_readonly() . ' ' : '') .
                    \ (&ft ==# 'vimfiler' ? vimfiler#get_status_string() :
                    \  &ft ==# 'unite' ? unite#get_status_string() : file_name ).
                    \ ('' !=# Lightline_modified() ? ' ' . Lightline_modified() : '')
    endfunction

    function! Lightline_fugitive() abort
        if &ft !~? 'vimfiler' && exists('*fugitive#head') && (winwidth(0) > 80)
            let branch = fugitive#head()
            return branch !=# '' ? '±'.branch : ''
        endif
        return ''
    endfunction

    function! Lightline_fileformat() abort
        return winwidth(0) > 80 ? &fileformat : ''
    endfunction

    function! Lightline_filetype() abort
        return winwidth(0) > 80 ? (&filetype !=# '' ? &filetype : 'no ft') : ''
    endfunction

    function! Lightline_fileencoding() abort
        return winwidth(0) > 80 ? (&fenc !=# '' ? &fenc : &enc) : ''
    endfunction

    function! Lightline_mode() abort
        return winwidth(0) > 80 ? lightline#mode() : ''
    endfunction

    function! Lightline_winnr() abort
        return winnr()
    endfunction

    function! Lightline_bufnr() abort
        return "b:" . bufnr('%')
    endfunction
endif "}}}2

if dein#tap('vim-qf') "{{{2
    let g:qf_mapping_ack_style = 1
endif "}}}2

if dein#tap('vimwiki') "}}}2
    let g:vimwiki_list = [{
                \ 'path': '~/Dropbox/wiki',
                \ 'index': 'main',
                \ }]
endif "}}}2


if dein#tap('tmuxline.vim')
    if ($TERM ==# 'screen' || $TERM ==# 'screen-256color')
                \ && !empty($TMUX)

        let g:tmuxline_powerline_separators = 0
        let g:tmuxline_separators = {
                    \ 'left' : '',
                    \ 'left_alt': '|',
                    \ 'right' : '',
                    \ 'right_alt' : '|',
                    \ 'space' : ' '}

        augroup tmuxline
            autocmd!
            autocmd VimEnter * call s:set_up_tmuxline()
        augroup END

        function! s:set_up_tmuxline() abort
            Tmuxline lightline
            TmuxlineSnapshot! ~/.cache/tmux/statusline.conf
        endfunction
    endif
endif "}}}2

if dein#tap('vim-easy-align') "{{{2
    " Start interactive EasyAlign in visual mode (e.g. vipga)
    xmap ga <Plug>(EasyAlign)
    " Start interactive EasyAlign for a motion/text object (e.g. gaip)
    nmap ga <Plug>(EasyAlign)
endif "}}}2

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" AFTER PLUGINS                                                            {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if filereadable(glob('~/.vimrc_local_post', 1))
    source ~/.vimrc_local_post
endif


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" -                                                                        {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim: textwidth=78
" vim: foldmethod=marker
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}

" -                                                                          {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" encoding for vim to use internally (why do I want this?)
set encoding=utf-8

" enable multi-byte utf-8 characters in this file
scriptencoding utf-8

"end-of-line formats that will be tried editing a new file
set fileformats=unix,dos

filetype on " enable file type detection and setting of the 'filetype' option
filetype plugin on " enable loading of file type plugin files
filetype indent on " enable loading of the file type indent file

syntax enable " enable syntax highlighting

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" UTILITY FUNCTIONS & VARIABLES                                              {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
let s:has_tmux = ($TERM ==# 'screen' || $TERM ==# 'screen-256color') && !empty($TMUX)
let s:has_windows = has('win32') || has('win64')
let s:has_terminal = has('nvim') || has('terminal')
let s:has_nvim = has('nvim')
let s:has_vim = !has('nvim')
let s:has_vim8 = has('patch-8.0.0039')

if s:has_windows
    let g:os_path_sep = '\'
else
    let g:os_path_sep = '/'
endif

let g:app = has('nvim') ?  'nvim' : 'vim'

if s:has_windows
    let g:config_path = $LOCALAPPDATA . '\' . g:app . '\'
    let g:data_path   = $LOCALAPPDATA . '\' . g:app . '-data\'
    let g:cache_path  = $LOCALAPPDATA . '\' . g:app . '-cache\'
else
    if empty($XDG_CONFIG_HOME)
        let g:config_path = $HOME . '/.config/' . g:app . '/'
    else
        let g:config_path = $XDG_CONFIG_HOME . '/' . g:app . '/'
    endif

    if empty($XDG_DATA_HOME)
        let g:data_path = $HOME . '/.local/share/' . g:app . '/'
    else
        let g:data_path = $XDG_DATA_HOME . '/' . g:app . '/'
    endif

    if empty($XDG_CACHE_HOME)
        let g:cache_path = $HOME . '/.cache/' . g:app . '/'
    else
        let g:cache_path = $XDG_CACHE_HOME . '/' . g:app . '/'
    endif
endif

let s:app_path = split(&runtimepath, ',')[0] . g:os_path_sep

function! s:make_private_directory(path) abort
    if !isdirectory(a:path)
        call mkdir(a:path, 'p', 0700)
    endif
endfunction

function! s:make_cache_path_str(name) abort
    return g:cache_path . a:name
endfunction

function! s:make_data_path_str(name) abort
    return g:data_path . a:name
endfunction

function! s:make_cache_directory(dir_name) abort
    let l:path = s:make_cache_path_str(a:dir_name)
    call s:make_private_directory(l:path)
    return l:path
endfunction

function! s:make_data_directory(dir_name) abort
    let l:path = s:make_data_path_str(a:dir_name)
    call s:make_private_directory(l:path)
    return l:path
endfunction

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" COMMAND LINE                                                               {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set history=10000 " keep more command-line history

set wildmenu " show command-line completions when pressing <Tab>
set wildmode=full " complete the next full match when pressing <Tab>

" character you have to type to start wildcard expansion and also works in
" mappings, unlink 'wildchar'
set wildcharm=<Tab>
" accept current completion (requires that wildcharm is set to <Tab>)
cnoremap <C-Y> <Space><bs><Tab>

" File Searching
" ignored files
set wildignore=*.o,*.obj,*.pyc,*.DS_Store,*.out,*.i,tags*,cscope.out,*.elf
" lower priority files suffixes
set suffixes=.bak,~,.o,.info,.swp,.obj,.git,.hg,.svn

set path=
set path+=.  " To search relative to the directory of the current file
set path+=,, " To search in the current directory
set path+=** " Relative to the current directory search recursively

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" CURSOR SETTINGS                                                            {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set scrolloff=5 " minimum number of lines to keep above & below the cursor
set sidescrolloff=5 " minimum number of columns to keep left & right of the cursor

if has('mouse')
    " enable the mouse
    set mouse=a
endif

if s:has_vim && !has('gui_running')
    " configure what mouse code vim will recognize in terminal mode
    if has('mouse_sgr')
        set ttymouse=sgr
    else
        set ttymouse=xterm2
    endif

    set ttyfast " indicate a fast terminal connection
endif

if has('nvim')
    " prevent showing weird symbols in terminal like Qs at the ends of lines
    " TODO this commented out for now to see if this is still a problem
    " set guicursor=
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" UNDO & SWAP                                                                {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set undofile " write undo history to files that can be restored on buffer read
set undolevels=20000 " maximum number of changes that can be undone
if s:has_windows
    execute 'set undodir=' . s:make_data_directory('undo') . '\\\\'
else
    execute 'set undodir=' . s:make_data_directory('undo') . '//'
endif


function! Undo_clean() abort
    let l:undo_files_string = globpath(&undodir, '*')
    let l:undo_files = split(l:undo_files_string, '\n')
    for l:undo_file in l:undo_files
        let l:real_file = substitute(l:undo_file, escape(&undodir, '\/\\'), '', 'g')

        if has('win32') || has('win64')
            let l:real_file = substitute(l:real_file, '%%', ':\', 'g')
            let l:real_file = substitute(l:real_file, '%', '\', 'g')
        else
            let l:real_file = substitute(l:real_file, '%', '/', 'g')
        endif

        if !filereadable(l:real_file)
            echo l:undo_file
            call delete(l:undo_file)
        endif
    endfor
endfunction

" remove undo files that no longer correspond to actual files
command! UndoClean call Undo_clean()

set noswapfile " disable swap files

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" BACKUP                                                                     {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set backup " enable backups vim-backup-tree takes care of the rest

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" LINE WRAPPING                                                              {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" maximum width line width, longer lines will be broken with a end of line
" characters after a white space
set textwidth=80

" when 'wrap' is enabled visually break long lines at a character in 'breakat'
set linebreak
if exists('+breakindent')
    " when 'wrap' is enabled visually wrapped lines will maintain first lines
    " indention level
    set breakindent
endif
set nowrap " don't wrap lines by default

if has('nvim')
    " hard-wrap to $MANWIDTH when using :Man
    let g:man_hardwrap = 1
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" SPELLING - THESAURUS - DOCS                                                {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" TODO this is a note about downloading spell file is this necessary anymore?
" to work around issue in nvim run "nvim -u NORC +set\ spell"

set spell " enable spell checking
set spelllang=en_us " use US English words for spell checking
let &spellfile = s:app_path . 'utils/spell/spellfile.add'
let &thesaurus = s:app_path . 'utils/thesaurus/thesaurus.txt'

" repeat the replacement done by z= for all matches
nnoremap !z= :<C-u>spellrepall<cr>

" generate help tags for custom help files
execute 'helptags ' . s:app_path . 'doc'

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" TABS, INDENTING & FORMAT OPTIONS                                           {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set expandtab " make <Tab> in insert mode insert spaces instead of tab characters
set tabstop=4 " width of tab characters appear
set shiftwidth=4 " width to used for a single indent
set softtabstop=4 " width inserted when pressing <Tab> in insert mode
set smarttab " enhances behavior of <Tab> and <BS> in insert mode

set autoindent " copy indent from current line when starting a new line

set formatoptions+=n " recognize lists
set formatlistpat+=\\\|^\\s*[-*]\\s* "recognize lists with * or -
set formatoptions+=j " delete comment character when joining commented lines
set formatoptions-=t "don't auto wrap based on 'textwidth'

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" FOLDING                                                                    {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set foldcolumn=2
set foldnestmax=3
set foldlevelstart=99

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" AUTOCMDS                                                                   {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if has('autocmd')
    augroup vimrc
        autocmd!
        autocmd BufWritePost *vimrc*,init.vim nested source $MYVIMRC
    augroup end
endif

if has('autocmd')
    augroup AllFiles
        autocmd!
        autocmd FocusLost * silent! wall
    augroup end
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" SEARCHING                                                                  {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set wrapscan "searches wrap around the end of the file
set incsearch " while searching show and highlight match as you type
set ignorecase " while searching the case of letters ignored
set smartcase " override 'ignorecase' if the search contains upper case chars

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" TAGS                                                                       {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
set tags=tags;/ " search backwards for the tags file

" cscope
set cscoperelative
set cscopequickfix=s-,c-,d-,i-,t-,e-
function! PrintCscopeOptions() abort
    echo 'g: Definition'
    echo 'c: Functions calling this function'
    echo 'd: Functions called by this function'
    echo 'f: This file'
    echo 'i: Files #including this file'
    echo 's: This C symbol'
    echo 't: This text string'
    echo 'e: This egrep pattern'
endfunction
execute 'nnoremap <leader>csf :call PrintCscopeOptions()<CR>:cs find '
execute 'nnoremap <leader>cs :call PrintCscopeOptions()<CR>:cs find   <C-r><C-w><HOME>' . repeat('<Right>',8)

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" GENERAL BEHAVIOR                                                           {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" use the system clipboard register + for yank, delete, change, and put
" operations
set clipboard=unnamedplus

" when splitting a window put the new window right of the current one.
set splitright

set nrformats-=octal " ignore octal numbers when using  <C-a> and <C-x>

"TODO see if this can be simplified
" disable dang error{visual}bells for good
if has('autocmd')
    augroup noBells
        autocmd!
        autocmd GUIEnter * set vb t_vb=
        autocmd VimEnter * set vb t_vb=
    augroup end
endif

set nostartofline " avoid moving the cursor column when navigating

" write the contents of the file, if it has been modified when navigating away
" from the file
set autowriteall

set autoread " re-read files that have been changed outside of vim
set backspace=indent,eol,start " allow backspacing to work as expected

" allow the cursor to be positioned where there are no actual character
set virtualedit+=all

set modeline " allow modeline options to be evaluated

if has('nvim')
    " shows the effects of a substitute commands as you type
    set inccommand=nosplit
endif

set diffopt+=vertical "always open diff side by side

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" UI OPTIONS                                                                 {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" set 'colorcolumn' position based on 'textwidth'
if has('autocmd')
    augroup colorcolumn
        autocmd!
        autocmd BufNewFile,BufWinEnter * let &colorcolumn = (&textwidth == 0 ? 0 : &textwidth + 1)
    augroup end
endif

" open a dialog for commands that can be confirmed/ can fail e.g. :q, :qa, :w
set confirm

set shortmess+=a "use abbreviations for short messages

" show current line number, and relative line numbers around it
set number
set relativenumber

set showcmd " show partial normal mode commands
set lazyredraw " don't redraw for non-typed normal mode commands e.g. macros
set laststatus=2 " always show status line
set showtabline=2 " always show tab line

" special characters to display for certain situations
set list
set listchars=trail:·,tab:→‸,extends:▶,precedes:◀,nbsp:‾

if v:version >= 800
    set signcolumn=yes
endif

" Highlight TODO, FIXME, NOTE, etc.
if has('autocmd') && v:version > 701
    highlight default link MyTodo Todo
    augroup todo
        autocmd!
        autocmd Syntax * match MyTodo '\v<(|NOTE|INFO|IDEA|IMPROVEMENT|QUESTION|TODO|FIXME|BUG|HACK|TRICKY|XXX)>'
    augroup end
endif

" gVim settings {{{2
if has ('gui_running')
    " Make GVim more like Terminal Vim
    set guioptions-=T "remove toolbar
    set guioptions-=r "remove right-hand scroll bar
    set guioptions-=l "remove right-hand scroll bar
    set guioptions=c "makes dialogs boxes appear like they do in console vim


    " Maximize windows GVim On Startup
    if has('autocmd') && s:has_windows
        augroup windowsgui:
            autocmd!
            autocmd GUIEnter * simalt ~x
        augroup end
    endif

    " Set Font
    try
        if s:has_windows
            set guifont=DejaVu_Sans_Mono:h9:cANSI,Lucida_Console:h9:cANSI,Consolas:h9:cANSI
        elseif has('mac')
            set guifont=DejaVu\ Sans\ Mono:h11,Monaco:h11
        elseif has('unix') && !has('mac') "linux
            set guifont=DejaVu\ Sans\ Mono\ 10
        endif
    catch
    endtry
endif "}}}2

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" MAPPINGS & COMMANDS                                                        {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

if !has('nvim') && &ttimeoutlen == -1
    set ttimeout " enable timeout when waiting for a key code sequence to complete
    set ttimeoutlen=100 " time in ms to wait for 'ttimeout'
endif

set updatetime=1000 " time to wait for swap file write/ CursorHold autocmd

let mapleader="\<Space>"

nnoremap [myleader] <Nop>
xnoremap [myleader] <Nop>
nmap go [myleader]
xmap go [myleader]

cnoremap [cmdleader] <Nop>
cmap <C-j> [cmdleader]

if executable('ag')
    set grepprg=ag\ --vimgrep\ $*
    set grepformat=%f:%l:%c:%m
elseif executable('ack')
    set grepprg=ack\ -H\ --nocolor\ --nogroup
endif

nnoremap sal :set hlsearch<CR>:redraw<CR>:substitute///gc<Left><Left><Left>
nnoremap sG :set hlsearch<CR>:redraw<CR>:.,$substitute///gc<Left><Left><Left>
nnoremap sae :set hlsearch<CR>:redraw<CR>:%substitute///gc<Left><Left><Left>

" When 'wrap' is enabled these mappings make basic navigation more intuitive
" when navigating between visually wrapped lines
nnoremap <expr> k (v:count == 0 ? 'gk' : 'k')
nnoremap <expr> j (v:count == 0 ? 'gj' : 'j')
nnoremap gk k
nnoremap gj j
xnoremap <expr> k (v:count == 0 ? 'gk' : 'k')
xnoremap <expr> j (v:count == 0 ? 'gj' : 'j')
xnoremap gk k
xnoremap gj j

nnoremap <leader>f :find<Space>
nnoremap <leader>fs :sfind<Space>
nnoremap <leader>fv :vert sfind<Space>
nnoremap <leader>ft :tabfind<Space>

nnoremap <leader>F :find <C-R>=expand('%:h') . g:os_path_sep<CR>
nnoremap <leader>fo :find <C-R>=substitute(expand('%:t'), '\(\(.\{1,}\.\)\w\+$\)\?', '\2', 'g')<CR>*<Tab>
nnoremap <leader>S :sfind <C-R>=expand('%:h') . g:os_path_sep<CR>
nnoremap <leader>V :vert sfind <C-R>=expand('%:h') . g:os_path_sep<CR>
nnoremap <leader>T :tabfind <C-R>=expand('%:h') . g:os_path_sep<CR>

nnoremap <leader>b :ls<CR>:buffer<Space>
nnoremap <leader>bs :ls<CR>:sbuffer<Space>
nnoremap <leader>bo :buffer <C-R>=substitute(expand('%:t'), '\(\(.\{1,}\.\)\w\+$\)\?', '\2', 'g')<CR>*<Tab>

" replace selection with spaces and enter replace mode
xnoremap gr r<Space>gvo<Esc>R

noremap <silent><leader>rt :retab<CR>

" underline current line with character of choice
nnoremap <silent> <leader>u :call <SID>under_line()<CR>
function! s:under_line() abort
    let l:char = escape(nr2char(getchar()), '\')
    normal! yyp
    execute ':s#\m\S.*\S\|\S#\=repeat(''' . l:char . ''',strlen(submatch(0)))#g'
endfunction

" format current paragraph wile in insert mode
inoremap <C-f> <Esc>gw{zea

" This gets CTRL-6 working on nvim-qt one windows (maybe other places too?)
nnoremap <C-6> <C-^>

" break out the current tab into a new window without leaving the current tab
nnoremap <expr> <C-w><C-t> (winnr('$') != 1 ? "<C-w>TgT" : "")

" open the current window's buffer in a new tab without breaking it out
nnoremap g<C-w>t :tabedit %<CR>

nnoremap <leader>to :call PreviewWord()<CR>
nnoremap <leader>tc :pclose<CR>
function! PreviewWord() abort
    if &previewwindow
        return
    endif

    let l:word_under_cursor = expand('<cword>')
    let l:is_word_under_cursor_a_letter = l:word_under_cursor =~# '\a'

    if l:is_word_under_cursor_a_letter

        " Delete any existing highlight before showing another tag
        silent! wincmd P  " jump to preview window
        if &previewwindow " if we really get there...
            match none    " delete existing highlight
            wincmd p      " back to old window
        endif

        " Try displaying a matching tag for the word under the cursor
        try
            execute ':ptag ' . l:word_under_cursor
        catch
            return
        endtry

        silent! wincmd P " jump to preview window
        if &previewwindow " if we really get there...
            if has('folding')
                silent! .foldopen  " don't want a closed fold
            endif
            call search('$', 'b')  " to end of previous line
            let l:word_under_cursor = substitute(l:word_under_cursor, '\\', '\\\\', '')
            call search('\<\V' . l:word_under_cursor . '\>')  " position cursor on match
            " Add a match highlight to the word at this position
            hi previewWord term=underline cterm=reverse gui=reverse
            execute 'match previewWord "\%' . line('.') . 'l\%' . col('.') . 'c\k*"'
            wincmd p " back to old window
        endif
    endif
endfun


function! s:in(group, item) abort
    if type(a:group) == type('')
        let l:group = split(a:group, '\zs')
        return index(l:group, a:item) <= 0
    endif
endfunction

" think of "yo" as "yoggle option"
nnoremap yosb :<C-U>set scrollbind!<CR>:set scrollbind?<CR>
nnoremap yocb :<C-U>set cursorbind!<CR>:set cursorbind?<CR>
nnoremap yomd :<C-U>set modifiable!<CR>:set modifiable?<CR>
nnoremap yoro :<C-U>set readonly!<CR>:set readonly?<CR>
nnoremap yot :<C-U>set textwidth=
nnoremap yocl :<C-U>setlocal conceallevel=
nnoremap yosw :<C-U>set shiftwidth=
nnoremap <silent> conf :<C-U>call <SID>scratch_toggle()<CR>
function! s:scratch_toggle() abort
    if match(&buftype, '\C\v'.'nofile') != -1
        set buftype-=nofile
    else
        set buftype+=nofile
    endif
endfunction
function! s:format_options_toggle(options, message) abort
    let l:options = split(a:options, '\zs')

    for l:option in l:options
        if s:in(&formatoptions, l:option)
            let l:add_or_subtract = '+='
            let l:message = printf('on: %s', a:message)
        else
            let l:add_or_subtract = '-='
            let l:message =  printf('off: %s', a:message)
        endif
        execute 'set formatoptions' . l:add_or_subtract . l:option
    endfor
    set formatoptions?
    echo l:message
endfunction
nnoremap yotw :<C-U>call <SID>format_options_toggle('t', 'auto wrap using textwidth')<CR>
nnoremap yopw :<C-U>call <SID>format_options_toggle('aw' 'auto formmating of paragraphs')<CR>

" reselect pasted or last changed text
nnoremap <expr> gpv '`[' . getregtype()[0] . '`]'

nnoremap <C-w>Q :tabclose<CR>

" Use <C-L> to clear the highlighting of :set hlsearch, and redraw the screen
nnoremap <silent> <C-L> :redraw!<CR>:nohlsearch<C-r>=has('diff')?'<Bar>diffupdate':''<CR><CR><C-l>

nnoremap <C-W>d :bd<CR>

" make more undos possible after leaving insert mode
inoremap <C-u> <C-g>u<C-u>
inoremap <C-w> <C-g>u<C-w>
inoremap <BS> <C-g>u<BS>
inoremap <Del> <C-g>u<Del>
inoremap <End> <C-g>u<End>
inoremap <Space> <C-g>u<Space>

" yank to end of line, kinda like D or C
noremap Y y$

" visual selection text object
xnoremap a/ gn
onoremap a/ gn
xnoremap i/ gn
onoremap i/ gn
xnoremap i? gN
onoremap i? gN
xnoremap a? gN
onoremap a? gN

" disable Ex mode key and use it to repeat the last q macro (love this)
nnoremap Q @q
" replay q macro for each line of a visual selection
xnoremap Q :normal! @q<CR>
" repeat last command for each line of a visual selection
xnoremap . :normal! .<CR>

" set path to present working directory locally
nnoremap cdl :lcd! %:h<CR>:pwd<CR>
nnoremap cd :cd! %:h<CR>:pwd<CR>

" paste after visual block/line selection
vnoremap <expr> gp '<C-v>A<C-r>'.v:register.'<Esc>'
" paste before visual block/line selection
vnoremap <expr> gP '<C-v>I<C-r>'.v:register.'<Esc>'

" navigation in command line
cnoremap <C-p> <UP>
cnoremap <C-n> <DOWN>
cnoremap <C-b> <LEFT>
cnoremap <C-f> <RIGHT>
cnoremap <C-a> <HOME>
cnoremap <C-e> <END>
" expand abbreviations
cnoremap <C-x> <C-]>
cnoremap <C-v> <C-f>

" fn file name foo.txt
" afp File Path  (/something/src/foo.txt)
" fp File Path relative  (src/foo.txt)
" ofn Other File Name (trail)
" aofp Other File Path
" ofp Other File Path Relative to pwd
" adp Directory Path (head) (/something/src)
" dp Directory Path Relative to pwd (head) (/something/src)
" pwd Present Working Directory
let s:extension_patter = '\(\(.\{1,}\.\)\w\+$\)\?'
let s:maps = [
            \     {
            \         'str': 'fn',
            \         'func': "expand('%:t')"
            \     },
            \     {
            \         'str': 'afp',
            \         'func': "expand('%:p')"
            \     },
            \     {
            \         'str': 'fp',
            \         'func': "expand('%')"
            \     },
            \     {
            \         'str': 'ofn',
            \         'func': "substitute(expand('%:t'), '"
            \         . s:extension_patter . "', '\\2', 'g')"
            \     },
            \     {
            \         'str': 'aofp',
            \         'func': "substitute(expand('%:p:r:.'), '"
            \         . s:extension_patter . "', '\\2', 'g')"
            \     },
            \     {
            \         'str': 'ofp',
            \         'func': "expand('%<') . '.'"
            \     },
            \     {
            \         'str': 'adp',
            \         'func': "expand('%:p:h') . g:os_path_sep"
            \     },
            \     {
            \         'str': 'dp',
            \         'func': "expand('%:h') . g:os_path_sep"
            \     },
            \     {
            \         'str': 'pwd',
            \         'func': 'getcwd()'
            \     }
            \  ]
for s:map in s:maps
    execute 'nnoremap <silent> <leader>y' . s:map.str . ' ' .
                \ ':let @*=' . s:map.func . '<CR>' .
                \ ':let @+=' . s:map.func . '<CR>' .
                \ ':let @"=' . s:map.func . '<CR>'
    execute 'cnoremap %' . s:map.str . ' <C-r>=' . s:map.func . '<CR>'
endfor

" accept completion (requires "set wildcharm = <Tab>)
cnoremap <C-y> <Space><BS><Tab>

cnoremap %date <C-r>=strftime('%Y-%m-%d')<CR>

let $zsh = '~/.zshrc'
let $zshl = '~/.zshrc_local'
let $shf = '~/.config/shell/functions.sh'
let $git = '~/.gitconfig'
let $gitl = '~/.gitconfig_local'
let $ps = '~/Documents/WindowsPowerShell/profile.ps1'
let $vim = '$MYVIMRC'
let $vimg = s:app_path . 'ginit.vim'
let $viml = '~/.vimrc_local'
let $tmux = '~/.tmux.conf'
let $t = '~/files/notes/todo.txt'
let $i = '~/files/notes/inbox.md'
let $j = '~/files/notes/journal.md'

cnoremap ~f ~/files
cnoremap ~p ~/files/projects
cnoremap ~n ~/files/notes
cnoremap ~df ~/dotfiles
cnoremap ~dfl ~/dotfiles_local

if s:has_terminal
    " Exit terminal
    tnoremap <C-\><C-\> <C-\><C-n>
    snoremap <C-\><C-\> <C-\><C-n>
    inoremap <C-\><C-\> <C-\><C-n>
    noremap <C-\><C-\> <C-\><C-n>

    " paste into terminal
    tnoremap <C-\>p <C-\><C-n>pi

    " paste register into terminal
    tnoremap <expr> <C-\><C-r> '<C-\><C-N>"'.nr2char(getchar()).'pi'

    nnoremap +. :<C-u>terminal<CR>
    nnoremap +.t :<C-u>tabedit %<CR>:lcd <C-r>=expand('%:h')<CR><CR>:terminal<CR>
    nnoremap +.\ :<C-u>vsplit %<CR>:lcd <C-r>=expand('%:h')<CR><CR>:vertical terminal<CR>
    nnoremap +.- :<C-u>rightbelow split %<CR>:lcd <C-r>=expand('%:h')<CR><CR>:terminal<CR>

    nnoremap ++ :<C-u>terminal<CR>
    nnoremap ++t :<C-u>tabedit .<CR>:terminal<CR>
    nnoremap +\ :<C-u>vsplit<CR>:vertical terminal<CR>
    nnoremap +- :<C-u>rightbelow split<CR>terminal<CR>

    if s:has_nvim
        augroup terminal
            autocmd TermOpen * setlocal nospell
        augroup end
    endif
endif


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" SCRIPTS                                                                    {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
nnoremap g** :<C-U>call AddToSearch('n')<CR>
xnoremap g* :<C-U>call AddToSearch('x')<CR>
function! AddToSearch(mode) abort
    let l:save_reg = @@
    if @/ !=# ''
        let @/ .= '\|'
    endif
    if a:mode ==# 'x'
        normal! gvy
    elseif a:mode ==# 'n'
        normal! yiw
    else
        let @@ = l:save_reg
    endif
    let @/ .= @@
    let @@ = l:save_reg
endfunction

nnoremap <leader>tp :ptjump <C-r><C-w><CR>

" create a tab that can be used to copy from while in a terminal
function! CopyTab() abort
    let winview = winsaveview()
    tabedit %
    set nonumber
    set norelativenumber
    set signcolumn=no
    set foldcolumn=0
    call winrestview(winview)
endfunction
command! -bang -nargs=0 -range=0 CopyTab call CopyTab()

command! -bar -range=% Reverse <line1>,<line2>g/^/m<line1>-1|nohl

" reverse selection kind of works
vnoremap <silent> <leader>rev :<c-u>let old_reg_a=@a<CR>
            \:let old_reg=@"<CR>
            \gv"ay
            \:let @a=substitute(@a, '.\(.*\)\@=',
            \ '\=@a[strlen(submatch(1))]', 'g')<CR>
            \gvc<C-R>a<Esc>
            \:let @a=old_reg_a<CR>
            \:let @"=old_reg<CR>


command! -nargs=* -range=0 -bang Seq
            \ call Seq(<count>, <line1>, <line2>, <q-args>, "<bang>")

function! Seq(count, first_line, last_line, cmdInput, bang) abort
    " anything within back ticks
    let l:rg_expr = '`\(.\{-1,}\)`'

    " 1 index if ! is used
    if a:bang !=# '!'
        let x = 0
    else
        let x = 1
    endif

    let @a = ''
    let r = ''
    for i in range(0, a:last_line-a:first_line) "TODO fails without a range
        let l:line = substitute(a:cmdInput, l:rg_expr, '\=eval(submatch(1))', 'g')
        echomsg l:line
        " call append(i+a:first_line, line)
        let r = r.l:line."\n"
        echomsg r
        let x = x + 1
    endfor
    call setreg('a', r,  'b')
    normal! "aP
endfunction

command! -nargs=* -range=0 -bang Renumber
            \ call <SID>renumber(<line1>, <line2>, "<bang>")
function! s:renumber(first_line, last_line, bang) abort
    let num_expr = '\v\C^[^ ]{-}\zs\d+\ze'
    " 0 index if ! is used
    if a:bang !=# '!'
        let s:renumber_index = 1
    else
        let s:renumber_index = 0
    endif

    execute a:first_line.','.a:last_line.'s#'.num_expr.'#\=s:increment()#'
endfunction

function! s:increment() abort
    let old_renumber_index = s:renumber_index
    let s:renumber_index = s:renumber_index + 1
    return old_renumber_index
endfunction

" add numbers to the front or end of a line
cabbrev numend s/$/\=1-line("'<")+line(".")/c
cabbrev numfront s/^/\=1-line("'<")+line(".")/c

function! Git_status() abort
    let output = system('git status --porcelain')
    let escaped = escape(output, ' ')
    let subbed_start = substitute(escaped, '^...\', '', 'g')
    let subbed = substitute(subbed_start, '\n...', ' ', 'g')
    execute 'args ' . subbed
endfunction


"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" BEFORE PLUGINS                                                             {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if filereadable(glob('.vimrc_project'))
    source .vimrc_project
endif

if filereadable(glob('~/.vimrc_local', 1))
    source ~/.vimrc_local
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" PLUGINS                                                                    {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

" Function to check if a vim-plug plugin is loaded
function! Is_plugin_installed(plugin_name) abort
    let result = 0
    if has_key(g:plugs, a:plugin_name)
        let result = 1
    else
        echomsg a:plugin_name . ': is not installed'
    endif
    return result
endfunction

let s:plugin_path = s:make_cache_directory('plugins')
let s:plugin_manager_path = s:make_cache_directory('plugin_manager')
let s:plugin_manager_autoload_path = s:plugin_manager_path . g:os_path_sep . 'autoload'
let s:is_first_time_setup = 0
if !isdirectory(s:plugin_manager_autoload_path)
    let s:is_first_time_setup = 1
    execute '!git clone https://github.com/junegunn/vim-plug.git '
                \ . s:plugin_manager_autoload_path
endif
if has('vim_starting')
    execute 'set runtimepath+=' . s:plugin_manager_path
endif


call plug#begin(s:plugin_path)
Plug 'Shougo/vimproc.vim', {'do': 'make'}

" text objects {{{2
Plug 'kana/vim-textobj-user'
Plug 'saihoooooooo/vim-textobj-space'
Plug 'Julian/vim-textobj-variable-segment'
Plug 'kana/vim-textobj-entire'
Plug 'kana/vim-textobj-indent'
Plug 'kana/vim-textobj-line'
Plug 'kana/vim-textobj-syntax'
Plug 'mattn/vim-textobj-url'
Plug 'glts/vim-textobj-comment'
Plug 'thinca/vim-textobj-between'
Plug 'osyo-manga/vim-textobj-multiblock'
Plug 'sgur/vim-textobj-parameter'
Plug 'osyo-manga/vim-textobj-blockwise'
"}}}2

" {u,de}nite {{{2
Plug 'Shougo/denite.nvim'
Plug 'Shougo/neoyank.vim' " depends on 'Shougo/denite.nvim'
Plug 'Shougo/neomru.vim' " depends on 'Shougo/denite.nvim'
Plug 'naquad/unite-digraphs' "  depends on 'Shougo/denite.nvim'
Plug 'Shougo/unite.vim'
" }}}2

Plug 'dyng/ctrlsf.vim'

" Operators
Plug 'kana/vim-operator-user'
Plug 'arecarn/vim-operator-mixed-case'
Plug 'kana/vim-operator-replace' " depends on 'kana/vim-operator-user'
Plug 'tpope/vim-surround'
Plug 'tommcdo/vim-exchange'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-repeat'
Plug 'vim-scripts/visualrepeat'
"}}}2
"
Plug 'junegunn/fzf'
Plug 'junegunn/fzf.vim'

" Folds
Plug 'arecarn/vim-clean-fold'
Plug 'arecarn/vim-fold-cycle' " {'branch' : 'topics/global_fold_cycling'}


" Visual Enhancements
Plug 'itchyny/lightline.vim'
Plug 'chreekat/vim-paren-crosshairs'
Plug 'junegunn/goyo.vim'
Plug 'nathanaelkane/vim-indent-guides'

if !s:has_windows
    Plug 'edkolev/tmuxline.vim'
endif

if s:has_nvim || s:has_vim8
    Plug 'w0rp/ale'
endif
Plug 'tpope/vim-dispatch'
if s:has_nvim
    Plug 'radenling/vim-dispatch-neovim' " depends on 'tpope/vim-dispatch'
endif
Plug 'janko-m/vim-test'


" Vim script Development
" Plug 'vim-jp/vital.vim'
" Plug 'junegunn/vader.vim'
" Plug 'vim-scripts/Decho'


" File Type + Syntax
Plug 'stephpy/vim-yaml' "and alternative YAML sine the built in one is slow
Plug 'tpope/vim-markdown'
Plug 'iamcco/markdown-preview.nvim',
            \ {
            \     'do': {-> mkdp#util#install()},
            \     'for': ['markdown', 'vim-plug']
            \ }
Plug 'jkramer/vim-checkbox'
Plug 'aklt/plantuml-syntax'
Plug 'dbeniamine/todo.txt-vim'
Plug 'romainl/vim-qf'
Plug 'octol/vim-cpp-enhanced-highlight'
Plug 'hynek/vim-python-pep8-indent'
Plug 'Shougo/Deol.nvim'
Plug 'elzr/vim-json'
Plug 'chrisbra/csv.vim'


" Colors
Plug 'romainl/Apprentice'
Plug 'jonsmithers/apprentice-lightline-experimental'

" Completions
if s:has_nvim || s:has_vim8
    Plug 'neoclide/coc.nvim', {'branch': 'release'}
endif

if has('patch-7.4.774') " requires v:completed_item feature
    Plug 'Shougo/echodoc.vim'
endif

Plug 'Shougo/neosnippet-snippets'
Plug 'Shougo/neosnippet.vim'

" Git / VCS
Plug 'tpope/vim-fugitive'
Plug 'lambdalisue/gina.vim'
Plug 'jreybert/vimagit'
Plug 'airblade/vim-rooter'
Plug 'cohama/agit.vim'
Plug 'mhinz/vim-signify'

" Diff
Plug 'AndrewRadev/linediff.vim'
Plug 'vim-scripts/diffchanges.vim'
Plug 'arecarn/vim-diff-utils', {'branch' : 'visual_mapping'}
Plug 'chrisbra/vim-diff-enhanced'
Plug 'will133/vim-dirdiff'

" Applications
Plug 'tpope/vim-vinegar'
if has('nvim')
    Plug 'Shougo/defx.nvim', { 'do': ':UpdateRemotePlugins' }
else
    Plug 'Shougo/defx.nvim'
    Plug 'roxma/nvim-yarp'
    Plug 'roxma/vim-hug-neovim-rpc'
endif

" Text Manipulation Commands / Mappings
Plug 'godlygeek/tabular'
Plug 'arecarn/vim-split-join'
Plug 'AndrewRadev/splitjoin.vim'
Plug 't9md/vim-textmanip'
Plug 'vim-scripts/ingo-library'
Plug 'vim-scripts/FormatToWidth' " depends on 'vim-scripts/ingo-library'

" Enhancements
Plug 'kana/vim-niceblock'
Plug 'tpope/vim-speeddating'
Plug 'tpope/vim-unimpaired'
Plug 'vim-scripts/UnconditionalPaste'
Plug 'arecarn/vim-auto-autoread'
Plug 'arecarn/vim-backup-tree'
Plug 'thinca/vim-qfreplace'
Plug 'tpope/vim-eunuch'
Plug 'arecarn/vim-spell-utils'
Plug 'tpope/vim-abolish'
Plug 'arecarn/vim-lost'
Plug 'mg979/vim-visual-multi'

" Word Under the Cursor Highlighting
Plug 't9md/vim-quickhl'
Plug 'dominikduda/vim_current_word'

" Search
Plug 'pgdouyon/vim-evanesco'
Plug 'mhinz/vim-grepper'

" Utilities
Plug 'talek/obvious-resize'
Plug 'vim-scripts/cmdalias.vim'
Plug 'arecarn/Preserve.vim'

" Interactive Tools/Modes
Plug 'dhruvasagar/vim-table-mode'
Plug 'arecarn/vim-selection'
Plug 'arecarn/vim-crunch' " depends on arecarn/vim-selection
Plug 'chrisbra/NrrwRgn'
Plug 'mbbill/undotree'

Plug 'arecarn/vim-binascii'
Plug 'arecarn/vim-frisk'

" Project Management
if s:has_vim8 || s:has_nvim
    Plug 'ludovicchabant/vim-gutentags'
    Plug 'liuchengxu/vista.vim'
endif
Plug 'tpope/vim-projectionist'

" Initialize plugin system
call plug#end()

if s:is_first_time_setup
    PlugInstall
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" PLUGINS CONFIG                                                             {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if Is_plugin_installed('vim_current_word') "{{{2
    " The word under cursor:
    let g:vim_current_word#highlight_current_word = 0
endif "}}}2

if Is_plugin_installed('defx.nvim') "{{{2

    " EXplore present working Directory
    command! Ex Defx -new <args>

    " EXplorer current File's directory
    command! Exf Defx -new `expand('%:p:h')` -search=`expand('%:p')`

    augroup defx_custom_settings
        autocmd!
        autocmd FileType defx call s:defx_custom_settings()
    augroup end

    function! s:defx_custom_settings() abort
        set number
        set relativenumber

        nnoremap <silent><buffer> <Tab> :<C-u>Defx -new -split=vertical -winwidth=<C-r>=winwidth("%")/2<CR><CR>
        nnoremap <silent><buffer><expr> <CR> defx#do_action('open')
        nnoremap <silent><buffer><expr> c defx#do_action('copy')
        nnoremap <silent><buffer><expr> m defx#do_action('move')
        nnoremap <silent><buffer><expr> p defx#do_action('paste')
        nnoremap <silent><buffer><expr> l defx#do_action('open')
        nnoremap <silent><buffer><expr> E defx#do_action('open', 'vsplit')
        nnoremap <silent><buffer><expr> P defx#do_action('preview')
        nnoremap <silent><buffer><expr> o defx#do_action('open_tree', 'toggle')
        nnoremap <silent><buffer><expr> K defx#do_action('new_directory')
        nnoremap <silent><buffer><expr> N defx#do_action('new_file')
        nnoremap <silent><buffer><expr> M defx#do_action('new_multiple_files')
        nnoremap <silent><buffer><expr> C defx#do_action('toggle_columns', 'mark:indent:icon:filename:type:size:time')
        nnoremap <silent><buffer><expr> S defx#do_action('toggle_sort', 'time')
        nnoremap <silent><buffer><expr> d defx#do_action('remove')
        nnoremap <silent><buffer><expr> r defx#do_action('rename')
        nnoremap <silent><buffer><expr> ! defx#do_action('execute_command')
        nnoremap <silent><buffer><expr> x defx#do_action('execute_system')
        nnoremap <silent><buffer><expr> yy defx#do_action('yank_path')
        nnoremap <silent><buffer><expr> . defx#do_action('toggle_ignored_files')
        nnoremap <silent><buffer><expr> ; defx#do_action('repeat')
        nnoremap <silent><buffer><expr> h defx#do_action('cd', ['..'])
        nnoremap <silent><buffer><expr> ~ defx#do_action('cd')
        nnoremap <silent><buffer><expr> q defx#do_action('quit')
        nnoremap <silent><buffer><expr> <Space> defx#do_action('toggle_select') . 'j'
        vnoremap <silent><buffer><expr> <Space> defx#do_action('toggle_select_visual')
        nnoremap <silent><buffer><expr> * defx#do_action('toggle_select_all')
        nnoremap <silent><buffer><expr> j line('.') == line('$') ? 'gg' : 'j'
        nnoremap <silent><buffer><expr> k line('.') == 1 ? 'G' : 'k'
        nnoremap <silent><buffer><expr> <C-l> defx#do_action('redraw')
        nnoremap <silent><buffer><expr> <C-g> defx#do_action('print')
        nnoremap <silent><buffer><expr> cd defx#do_action('change_vim_cwd')
    endfunction
endif "}}}2

if Is_plugin_installed('vim-json')
    " disable concealing of quotes
    let g:vim_json_syntax_conceal = 0
endif "}}}2


if Is_plugin_installed('vim-visual-multi') "{{{2
    let g:VM_mouse_mappings = 1
endif "}}}2

if Is_plugin_installed('markdown-preview.nvim') "{{{2
    let g:mkdp_auto_close = 0
    let g:mkdp_preview_options = {
                \ 'mkit': {},
                \ 'katex': {},
                \ 'uml': {},
                \ 'maid': {},
                \ 'disable_sync_scroll': 1,
                \ 'sync_scroll_type': 'middle',
                \ 'hide_yaml_meta': 1,
                \ 'sequence_diagrams': {},
                \ 'flowchart_diagrams': {},
                \ 'content_editable': v:false
                \ }
endif "}}}2

if Is_plugin_installed('csv.vim')
    augroup csv
        autocmd!
        autocmd CursorHold csv WhatColumn!
    augroup end
endif "}}}2

if Is_plugin_installed('vim-gutentags') "{{{2
    let g:gutentags_project_root = ['.project_root']
    let g:gutentags_define_advanced_commands = 1
endif "}}}2


" TODO this doesn't get much use
if Is_plugin_installed('vim-lost') "{{{2
    augroup vimrc
        autocmd!
        autocmd FileType markdown let b:lost_regex = '\v^#'
    augroup end
endif "}}}2

if Is_plugin_installed('vim-backup-tree') "{{{2
    let g:backup_tree = s:make_data_directory('backup')
endif "}}}2

if Is_plugin_installed('vim-diff-enhanced') "{{{2
    let &diffexpr='EnhancedDiff#Diff("git diff", "--diff-algorithm=patience")'
endif "}}}2

if Is_plugin_installed('echodoc.vim') "{{{2
    let g:echodoc#enable_at_startup = 1
    if &showmode
        set cmdheight=2
    endif
    set completeopt-=preview
    set shortmess+=c
endif "}}}2

if Is_plugin_installed('Deol.nvim') "{{{2
    let g:deol#prompt_pattern = '.\{-} \d\d:\d\d:\d\d %'
endif "}}}2

if Is_plugin_installed('coc.nvim') "{{{2
    " list extensions that should be installed if they aren't already
    let g:coc_global_extensions = [
                \ 'coc-clangd',
                \ 'coc-cmake',
                \ 'coc-yank',
                \ 'coc-vimlsp',
                \ 'coc-python',
                \ 'coc-neosnippet',
                \ ]

    " disable warning about using older version of node.js
    let g:coc_disable_startup_warning = 1

    " go to code navigation.
    nmap <silent> <leader>ld <Plug>(coc-definition)
    nmap <silent> <leader>li <Plug>(coc-implementation)
    nmap <silent> <leader>lt <Plug>(coc-type-definition)
    nmap <silent> <leader>lr <Plug>(coc-references)
    nmap <silent><expr> <leader>ld CocActionAsync('doHover')

    " substitute symbol
    nmap <leader>ls <Plug>(coc-rename)

    " Formatting selected code.
    xmap <leader>lfm <Plug>(coc-format-selected)
    nmap <leader>lfm <Plug>(coc-format-selected)

    augroup coc_group
        autocmd!
        " Update signature help on jump placeholder.
        autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
    augroup end

    " Applying codeAction to the selected region.
    " Example: `<leader>laap` for current paragraph
    xmap <silent><leader>la <Plug>(coc-codeaction-selected)
    nmap <silent><leader>la <Plug>(coc-codeaction-selected)

    " Apply AutoFix to problem on the current line.
    nmap <leader>lf  <Plug>(coc-fix-current)

    " Map function and class text objects
    " NOTE: Requires 'textDocument.documentSymbol' support from the language
    " server.
    xmap <silent> if <Plug>(coc-funcobj-i)
    omap <silent> if <Plug>(coc-funcobj-i)
    xmap <silent> af <Plug>(coc-funcobj-a)
    omap <silent> af <Plug>(coc-funcobj-a)
    xmap <silent> icl <Plug>(coc-classobj-i)
    omap <silent> icl <Plug>(coc-classobj-i)
    xmap <silent> acl <Plug>(coc-classobj-a)
    omap <silent> acl <Plug>(coc-classobj-a)

    " Use CTRL-S for selections ranges.
    " Requires 'textDocument/selectionRange' support of language server.
    nmap <silent> <C-s> <Plug>(coc-range-select)
    xmap <silent> <C-s> <Plug>(coc-range-select)

    " format current buffer.
    command! -nargs=0 Lformat :call CocAction('format')

    " fold current buffer.
    command! -nargs=? Lfold :call CocAction('fold', <f-args>)

    " organize imports of the current buffer.
    command! -nargs=0 Lorg :call CocAction('runCommand', 'editor.action.organizeImport')

    " Mappings for CoCList
    nnoremap <silent> <leader>lld :<C-u>CocList diagnostics<CR>
    nnoremap <silent> <leader>lle :<C-u>CocList extensions<CR>
    nnoremap <silent> <leader>llc :<C-u>CocList commands<CR>
    nnoremap <silent> <leader>llo :<C-u>CocList outline<CR>
    " search workspace symbols.
    nnoremap <silent> <leader>lls :<C-u>CocList -I symbols<CR>
    " do default action for next item.
    nnoremap <silent> <leader>llj :<C-u>CocNext<CR>
    " do default action for previous item.
    nnoremap <silent> <leader>llk :<C-u>CocPrev<CR>
    nnoremap <silent> <leader>llr :<C-u>CocListResume<CR>
    " List recent yanks
    nnoremap <silent> <leader>ly  :<C-u>CocList -A --normal yank<CR>

endif "}}}2

if Is_plugin_installed('neosnippet-snippets') "{{{2
    imap <C-e> <Plug>(neosnippet_expand_or_jump)
    smap <C-e> <Plug>(neosnippet_expand_or_jump)
    xmap <C-e> <Plug>(neosnippet_expand_target)

    if has('conceal')
        set conceallevel=2 concealcursor=i
    endif

    let g:neosnippet#snippets_directory = s:app_path . 'utils/snippets'
    let g:neosnippet#data_directory = s:make_cache_path_str('neosnippet')
endif "}}}2

if Is_plugin_installed('unite.vim') "{{{2
    let g:unite_data_directory = s:make_cache_path_str('unite')
    let g:unite_winheight = 10
    let g:unite_split_rule = 'botright'
    call unite#filters#sorter_default#use(['sorter_rank'])
endif "}}}2

if Is_plugin_installed('denite.nvim') "{{{2
    if Is_plugin_installed('unite-digraphs')
        command! Digraphs Denite unite:digraphs
    endif

    if Is_plugin_installed('neoyank.vim')
        nnoremap [myleader]p  :<C-u>Denite -mode=normal neoyank<CR>
        xnoremap [myleader]p  dk:<C-u>Denit -mode=normale neoyank<CR>

        let g:neoyank#file = s:make_data_path_str('neoyank/history')
    endif

    if Is_plugin_installed('neomru.vim')
        nnoremap [myleader]r :<C-u>Denite file_mru<CR>

        let g:neomru#file_mru_path = s:make_cache_path_str('neomru/file')
        let g:neomru#directory_mru_path = s:make_cache_path_str('neomru/directory')
    endif

    nnoremap [myleader]d :<C-u>Denite directory_rec<CR>
    nnoremap [myleader]f :<C-u>Denite file_rec<CR>
    nnoremap [myleader]rg :<C-u>Denite register<CR>
    nnoremap [myleader]b  :<C-u>Denite buffer<CR>
    nnoremap [myleader]l  :<C-u>Denite line<CR>
    nnoremap [myleader]t  :<C-u>Denite tag<CR>
    nnoremap [myleader]:  :<C-u>Denite<Space><C-d>
    cnoremap <silent> <C-r><C-r> <C-u>Denite command_history<CR>
    cnoremap <silent> <C-o> <C-u>Denite command<CR>

    command! Messages Denite output:message

    " Define mappings
    augroup denite_custom_settings
        autocmd!
        autocmd FileType denite call s:denite_custom_settings()
    augroup end
    function! s:denite_custom_settings() abort
        nnoremap <silent><buffer><expr> <CR> denite#do_map('do_action')
        nnoremap <silent><buffer><expr> d denite#do_map('do_action', 'delete')
        nnoremap <silent><buffer><expr> p denite#do_map('do_action', 'preview')
        nnoremap <silent><buffer><expr> q denite#do_map('quit')
        nnoremap <silent><buffer><expr> i denite#do_map('open_filter_buffer')
        nnoremap <silent><buffer><expr> <Space> denite#do_map('toggle_select').'j'
    endfunction

endif "}}}2

if Is_plugin_installed('fzf') "{{{2
    nnoremap [myleader]f :FZF<CR>
    nnoremap [myleader]f<Space> :FZF<Space>
endif "}}}2

if Is_plugin_installed('vim-grepper') "{{{2
    nmap [myleader]g: :Grepper<CR>
    nmap [myleader]g <Plug>(GrepperOperator)
    xmap [myleader]g <Plug>(GrepperOperator)
endif "}}}2

if Is_plugin_installed('vim-dispatch') "{{{2
    nnoremap [myleader]m :Make<CR>
    nnoremap [myleader]m: :Make<Space>
endif "}}}2

if Is_plugin_installed('vim-fugitive') "{{{2
    command! -nargs=* G :Git <args>
    nnoremap <leader>gs :Gstatus<CR>
    nnoremap <leader>gd :Gdiff<CR>
    nnoremap <leader>gd<Space> :Gdiff<Space>
    nnoremap <leader>gd1 :Gdiff HEAD~1<CR>
    nnoremap <leader>gd2 :Gdiff HEAD~2<CR>
    nmap <leader>gc :Gstatus<CR>cc<C-w>T:vs<CR>/>8<CR>z<CR><C-w>p
    nmap ]gd :Gstatus<CR>30<C-w>_<C-w>K<C-n>D
    nmap [gd :Gstatus<CR>30<C-w>_<C-w>K<C-p>D
    nmap ]g :Gstatus<CR>30<C-w>_<C-w>K<C-n><CR>
    nmap [g :Gstatus<CR>30<C-w>_<C-w>K<C-p><CR>

    " Jump to last known cursor position on BufReadPost
    " Don't do it when the position is invalid or when inside an event handler
    " (happens when dropping a file on gvim).
    " NOTE: read viminfo/marks, but removed: causes issues with jumplist sync
    " across Vim instances
    " \   rviminfo |
    " NOTE: removed for SVN commit messages: && fnamemodify(bufname('%'), ':t') != 'svn-commit.tmp'
    " ref: :h last-position-jump
    fun! AutojumpLastPosition()
        if ! exists('b:autojumped_init')
            let b:autojumped_init = 1
            if &filetype !=# 'gitcommit' && &filetype !=# 'diff' && ! &diff && line("'\"") <=# line('$') && line("'\"") > 0
                " NOTE: `zv` is ignored with foldlevel in modeline.
                exe 'normal! g`"zv'
            endif
        endif
    endfun

    " Follow symlinks when opening a file {{{
    " NOTE: this happens with directory symlinks anyway (due to Vim's chdir/getcwd
    "       magic when getting filenames).
    " Sources:
    "  - https://github.com/tpope/vim-fugitive/issues/147#issuecomment-7572351
    "  - http://www.reddit.com/r/vim/comments/yhsn6/is_it_possible_to_work_around_the_symlink_bug/c5w91qw
    function! MyFollowSymlink(...) abort
        if exists('w:no_resolve_symlink') && w:no_resolve_symlink
            return
        endif
        if &filetype ==# 'help'
            return
        endif
        let fname = a:0 ? a:1 : expand('%')
        if fname =~# '^\w\+:/'
            " Do not mess with 'fugitive://' etc.
            return
        endif
        let fname = simplify(fname)

        let resolvedfile = resolve(fname)
        if resolvedfile == fname
            return
        endif
        let resolvedfile = fnameescape(resolvedfile)
        let sshm = &shortmess
        set shortmess+=A  " silence ATTENTION message about swap file (would get displayed twice)
        redraw  " Redraw now, to avoid hit-enter prompt.
        exec 'file ' . resolvedfile
        let &shortmess=sshm

        call AutojumpLastPosition()

        if &modifiable
            " Only display a note when editing a file, especially not for `:help`.
            redraw  " Redraw now, to avoid hit-enter prompt.
            echomsg 'Resolved symlink: =>' resolvedfile
        endif

        edit
    endfunction
    command! -bar FollowSymlink call MyFollowSymlink()
endif "}}}2

if Is_plugin_installed('vim-split-join') "{{{2
    command! -range -bang SplitS <line1>,<line2>Split<bang>/[^[:space:]]\zs\s\+/
endif "}}}2

if Is_plugin_installed('tabular') "{{{2
    nnoremap <leader>a :Tabularize/
    xnoremap <leader>a :Tabularize/
endif "}}}2

if Is_plugin_installed('vim-table-mode') "{{{2
    let g:table_mode_corner = '|'
    let g:table_mode_separator = '|'
endif "}}}2

if Is_plugin_installed('vim-indent-guides') "{{{2
    nmap <silent> coig <Plug>IndentGuidesToggle
    let g:indent_guides_enable_on_vim_startup = 0
    let g:indent_guides_default_mapping = 0
    let g:indent_guides_guide_size = 1
    let g:indent_guides_start_level = 2
endif "}}}2

if Is_plugin_installed('vim-textmanip') "{{{2
    xmap <C-j> <Plug>(textmanip-move-down)
    xmap <C-k> <Plug>(textmanip-move-up)
    xmap <C-h> <Plug>(textmanip-move-left)
    xmap <C-l> <Plug>(textmanip-move-right)

    xmap g<C-j> <Plug>(textmanip-duplicate-down)
    xmap g<C-k> <Plug>(textmanip-duplicate-up)
    xmap g<C-h> <Plug>(textmanip-duplicate-left)
    xmap g<C-l> <Plug>(textmanip-duplicate-right)

    xmap gb<C-j> <Plug>(textmanip-blank-below)
    xmap gb<C-k> <Plug>(textmanip-blank-above)

    " toggle insert/replace with
    nmap yotm <Plug>(textmanip-toggle-mode)
endif "}}}2

if Is_plugin_installed('vim-quickhl') "{{{2
    nmap gm <Plug>(quickhl-manual-this)
    xmap gm <Plug>(quickhl-manual-this)
    nmap gmx <Plug>(quickhl-manual-reset)
    xmap gmx <Plug>(quickhl-manual-reset)
endif "}}}2

if Is_plugin_installed('cmdalias.vim') "{{{2
    command! Pwf echo expand('%:p')
    augroup VIMRC_aliases
        autocmd!
        autocmd VimEnter * Alias pwf Pwf
        autocmd VimEnter * Alias ex Explore
        autocmd VimEnter * Alias sex Sexplore
        autocmd VimEnter * Alias tex Texplore
        autocmd VimEnter * Alias vex Vexplore
    augroup end
endif "}}}2

if Is_plugin_installed('FormatToWidth') "{{{2
    xmap gQ <Plug>FormatToWidth
endif "}}}2

if Is_plugin_installed('linediff.vim') "{{{2
    xnoremap <leader>lnd :Linediff<CR>
endif "}}}2

if Is_plugin_installed('vim-textobj-between') "{{{2
    let g:textobj_between_no_default_key_mappings = 1
    xmap am <Plug>(textobj-between-a)
    omap am <Plug>(textobj-between-a)
    xmap im <Plug>(textobj-between-i)
    omap im <Plug>(textobj-between-i)
endif "}}}2

if Is_plugin_installed('vim-markdown') "{{{2
    let g:markdown_fenced_languages = ['python', 'c', 'cpp', 'bash=sh']
    let g:markdown_syntax_conceal = 0
    let g:markdown_folding = 1
endif "}}}2

if Is_plugin_installed('undotree') "{{{2
    nnoremap [myleader]ut :UndotreeToggle<CR>:UndotreeFocus<CR>
endif "}}}2

if Is_plugin_installed('goyo.vim') "{{{2
    nnoremap yof :<C-u>call SetGoyo(v:count)<CR>

    function! s:goyo_enter() abort
        let b:wrap_cache = &wrap
        let &wrap = 1
        let b:list_cache = &list
        let &list = 0
        let b:cursorline = &cursorline
        let &cursorline = 1
    endfunction

    function! s:goyo_leave() abort
        let &wrap = b:wrap_cache
        let &list = b:list_cache
        let &cursorline = b:cursorline
    endfunction

    augroup goyo
        autocmd!
        autocmd User GoyoEnter nested call <SID>goyo_enter()
        autocmd User GoyoLeave nested call <SID>goyo_leave()
    augroup end

    let signcolumn_width = &signcolumn !=# 'no' ? 2 : 0
    let g:goyo_width = 80 + signcolumn_width + &foldcolumn
    function! SetGoyo(num) abort
        if a:num == 0
            Goyo
        else
            execute 'Goyo ' . string(a:num)
        endif
    endfunction
endif "}}}2

if Is_plugin_installed('todo.txt-vim') "{{{2
    let g:Todo_txt_prefix_creation_date = 1
    let g:TodoTxtStripDoneItemPriority = 1

    augroup TODO_TXT
        autocmd!
        autocmd BufNewFile,BufRead *todo.txt,*done.txt set filetype=todo
        autocmd BufNewFile,BufRead todo*.txt,done*.txt set filetype=todo
        autocmd FileType todo call s:todo_txt_settings()
        autocmd FileType todo setlocal formatoptions-=t
    augroup end

    function! s:get_context(line) abort "{{{3
        return matchstr(getline(a:line), '@[^ ]\+')
    endfunction "}}}3

    function! s:get_project(line) abort "{{{3
        return matchstr(getline(a:line), '+[^ ]\+')
    endfunction "}}}3

    function! Todo_fold_text(foldchar) abort "{{{3
        let line = s:get_context(v:foldstart)
        let lines_count = v:foldend - v:foldstart + 1
        let lines_count_text = '| ' . printf('%10s', lines_count . ' todos') . ' |'
        let foldtextstart = strpart(line, 0, (winwidth(0)*2)/3)
        let foldtextend = lines_count_text . repeat(a:foldchar, 8)
        let foldtextlength = strlen(substitute(foldtextstart . foldtextend, '.', 'x', 'g')) + &foldcolumn
        return foldtextstart . repeat(a:foldchar, winwidth(0)-foldtextlength) . foldtextend
    endfunction "}}}3

    function! Todo_fold(lnum) abort "{{{3
        let this_context = s:get_context(a:lnum)
        let next_context = s:get_context(a:lnum - 1)

        let fold_level = '0'

        if this_context ==# next_context
            let fold_level = '1'
        else
            let fold_level = '>1'
        endif

        return fold_level
    endfunction "}}}3

    nnoremap <localleader>w :s/\s*@[a-z-]\+\s*$\\|\s*$/ @work/<CR>:nohlsearch<CR>
    xnoremap <localleader>w :s/\s*@[a-z-]\+\s*$\\|\s*$/ @work/<CR>:nohlsearch<CR>
    nnoremap <localleader>h :s/\s*@[a-z-]\+\s*$\\|\s*$/ @home/<CR>:nohlsearch<CR>
    xnoremap <localleader>h :s/\s*@[a-z-]\+\s*$\\|\s*$/ @home/<CR>:nohlsearch<CR>

    function! s:todo_txt_settings() abort "{{{3
        try
            execute "iunmap <buffer> date\<Tab>"
            iunmap <buffer> due:
        catch
        endtry

        " update time
        " TODO fix issue where search pattern leaks into search history
        nnoremap <localleader>ud :s/\d\d\d\d-\d\d\-\d\d/\=strftime("%Y-%m-%d")/<CR>

        setlocal foldmethod=expr
        setlocal iskeyword+=+,_,.
        setlocal iskeyword+=@-@ " add literal @

        if Is_plugin_installed('neocomplete') "{{{3
            " use iskeyword characters in neocompletion
            let keyword_patterns = {}
            let keyword_patterns.todo = '\k\+'
            call neocomplete#custom#source('buffer',
                        \ 'keyword_patterns', keyword_patterns)
        endif
    endfunction "}}}3
endif "}}}2

if Is_plugin_installed('obvious-resize') "{{{2
    " map F9 - F12 (like hjkl) to resize windows
    nnoremap <silent><Left> :ObviousResizeLeft<CR>
    nnoremap <silent><Down> :ObviousResizeDown<CR>
    nnoremap <silent><Up> :ObviousResizeUp<CR>
    nnoremap <silent><Right> :ObviousResizeRight<CR>
endif "}}}2

if Is_plugin_installed('Preserve.vim') "{{{2
    command! -bar -range=% TrimLead PreserveSave|<line1>,<line2>s,^\s\+,,ge|PreserveRestore
    command! -bar -range=% TrimTrail PreserveSave|<line1>,<line2>s,\s\+$,,ge|PreserveRestore
    command! -bar -range=% Trim <line1>,<line2>TrimTrail<bar>TrimLead
    noremap <silent>d<Space>t :TrimTrail<CR>
    nnoremap =ae :call Preserve("normal! gg=G")<CR>
    nnoremap =ie :call Preserve("normal! gg=G")<CR>
    nnoremap yae :call Preserve("normal! ggyG")<CR>
    nnoremap yie :call Preserve("normal! ggyG")<CR>

    " TODO report error to vim about using the :s and :g commands reversed, it
    " reports more values than expected
    nnoremap g/ :call Preserve("echo @/<Bar>%s///ng<Bar>g//p")<CR>
endif "}}}2

if Is_plugin_installed('vim-crunch') "{{{2
    let g:crunch_user_variables = {'e': exp(1),  'pi':3.14159265359}
    let g:crunch_result_type_append = 2
    cabbrev Cr Crunch
endif "}}}2

if Is_plugin_installed('vim-surround') "{{{2
    " custom surround using :
    let g:surround_58 = "\1Surround\1\r\1\1"
endif "}}}2

if Is_plugin_installed('vim-clean-fold') "{{{2
    set foldmethod=expr
    set foldtext=clean_fold#fold_text_minimal()
    set foldexpr=clean_fold#fold_expr(v:lnum)
else
    set foldmethod=indent
endif "}}}2

if Is_plugin_installed('vim-rooter') "{{{2
    let g:rooter_manual_only = 1
endif "}}}2

if Is_plugin_installed('vim-fold-cycle') "{{{2
    let g:fold_cycle_default_mapping = 0
    nmap zo <Plug>(fold-cycle-open)
    nmap zc <Plug>(fold-cycle-close)
    nmap zO <Plug>(fold-cycle-open-all)
    nmap zC <Plug>(fold-cycle-close-all)
    nmap zA <Plug>(fold-cycle-toggle-all)
    " Won't close when max fold is opened
    let g:fold_cycle_toggle_max_open  = 0
    " Won't open when max fold is closed
    let g:fold_cycle_toggle_max_close = 0
    " nmap zr <Plug>(fold-cycle-open-global)
    " nmap zm <Plug>(fold-cycle-close-global)
endif "}}}2

if Is_plugin_installed('vim-operator-replace') "{{{2
    map _ <Plug>(operator-replace)
endif "}}}2

if Is_plugin_installed('Apprentice') "{{{2
    set background=dark
    colorscheme apprentice
endif "}}}2

if Is_plugin_installed('lightline.vim') "{{{2
    let g:lightline = {
                \ 'colorscheme': g:colors_name,
                \ 'active': {
                \     'right': [['winnr'], ['fugitive', 'filename', 'bufnr']],
                \     'left': [['paste', 'lineinfo' ],
                \                ['percent' ],
                \                ['fileformat', 'fileencoding', 'filetype']]
                \ },
                \ 'inactive' : {
                \     'right': [['winnr'], ['filename', 'bufnr']],
                \     'left': [['lineinfo' ],
                \                ['percent' ],
                \                ['fileformat', 'fileencoding', 'filetype']]
                \ },
                \ 'component_function': {
                \     'modified': 'Lightline_modified',
                \     'readonly': 'Lightline_readonly',
                \     'fugitive': 'Lightline_fugitive',
                \     'filename': 'Lightline_filename',
                \     'fileformat': 'Lightline_fileformat',
                \     'filetype': 'Lightline_filetype',
                \     'fileencoding': 'Lightline_fileencoding',
                \     'winnr': 'Lightline_winnr',
                \     'bufnr': 'Lightline_bufnr',
                \ }}

    function! Lightline_modified() abort
        return &filetype =~# 'help\|dirvish' ? '' : &modified ? '+' : &modifiable ? '' : '-'
    endfunction

    function! Lightline_readonly() abort
        return &filetype !~? 'help\|dirvish' && &readonly ? 'RO' : ''
    endfunction

    function! Lightline_filename() abort
        let file_name = bufname('%')

        if file_name ==# ''
            let file_name = '[No Name]'
        else
            if winwidth(0) - len(file_name) < 40
                let file_name = substitute(file_name, '\v([^/\\:])[^/\\:]*([/\\])', '\1\2', 'g' )
            endif
        endif

        return ('' !=# Lightline_readonly() ? Lightline_readonly() . ' ' : '') .
                    \ file_name .
                    \ ('' !=# Lightline_modified() ? ' ' . Lightline_modified() : '')
    endfunction

    function! Lightline_fugitive() abort
        if &filetype !~? 'dirvish' && exists('*fugitive#head') && (winwidth(0) > 80)
            let branch = fugitive#head()
            return branch !=# '' ? '±'.branch : ''
        endif
        return ''
    endfunction

    function! Lightline_fileformat() abort
        return winwidth(0) > 80 ? &fileformat : ''
    endfunction

    function! Lightline_filetype() abort
        return winwidth(0) > 80 ? (&filetype !=# '' ? &filetype : 'no ft') : ''
    endfunction

    function! Lightline_fileencoding() abort
        return winwidth(0) > 80 ? (&fileencoding !=# '' ? &fileencoding : &encoding) : ''
    endfunction

    function! Lightline_winnr() abort
        return winnr()
    endfunction

    function! Lightline_bufnr() abort
        return 'b:' . bufnr('%')
    endfunction
endif "}}}2

if Is_plugin_installed('vim-qf') "{{{2
    " auto opening the quickfix resets the &makeprg :(
    let g:qf_auto_open_quickfix = 0
endif "}}}2


if !s:has_windows && Is_plugin_installed('tmuxline.vim')
    if ($TERM ==# 'screen' || $TERM ==# 'screen-256color')
                \ && !empty($TMUX)

        let g:tmuxline_powerline_separators = 0
        let g:tmuxline_separators = {
                    \ 'left' : '',
                    \ 'left_alt': '|',
                    \ 'right' : '',
                    \ 'right_alt' : '|',
                    \ 'space' : ' '}

        augroup tmuxline
            autocmd!
            autocmd VimEnter * call s:set_up_tmuxline()
        augroup end

        function! s:set_up_tmuxline() abort
            Tmuxline lightline
            TmuxlineSnapshot! ~/.cache/tmux/statusline.conf
        endfunction
    endif
endif "}}}2

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" AFTER PLUGINS                                                              {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if !exists('g:loaded_matchit')
            \ && findfile('plugin/matchit.vim', &runtimepath) ==# ''
    runtime! macros/matchit.vim
endif


packadd termdebug

if exists('*Vimrc_local_plugin_config')
    call Vimrc_local_plugin_config()
endif

"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
" -                                                                          {{{
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" vim: textwidth=80
" vim: foldmethod=marker
"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""}}}
